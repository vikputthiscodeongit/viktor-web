/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./components/form/form-controller.js":
/*!********************************************!*\
  !*** ./components/form/form-controller.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ initForm)\n/* harmony export */ });\n/* harmony import */ var _helpers_js_create_els__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/js/create-els */ \"./helpers/js/create-els.ts\");\n/* harmony import */ var _helpers_js_create_els__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_helpers_js_create_els__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _form_mc_form_mc_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../form-mc/form-mc-controller */ \"./components/form-mc/form-mc-controller.ts\");\n/* harmony import */ var _form_mc_form_mc_controller__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_form_mc_form_mc_controller__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _codebundlesbyvik_simple_notifier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codebundlesbyvik/simple-notifier */ \"./node_modules/@codebundlesbyvik/simple-notifier/dist/js/simple-notifier.esm.js\");\n\r\n\r\n\r\n\r\nconst USER_STATUS_MESSAGES = {\r\n    200: \"Message sent - I'll be in touch soon :).\",\r\n    405: \"An error occurred - your message has not been sent. Please try again at a later time.\",\r\n    422: \"One or more fields failed validation. Please check and correct them.\",\r\n    500: \"An unknown error occurred - your message has not been sent. Please try again at a later time.\",\r\n    502: [\r\n        \"Messsage failed to send - please try submitting it again in a few minutes.\",\r\n        \"The message has been saved to your device, so you may also try again at a later time.\"\r\n    ]\r\n};\r\n\r\nconst FORM_MSG_STORED_EL_SKELETONS = {\r\n    fieldset: {\r\n        el: \"fieldset\"\r\n    },\r\n    field: {\r\n        el: \"div\",\r\n        attrs: {\r\n            class: \"field\"\r\n        }\r\n    },\r\n    explainer: {\r\n        el: \"p\",\r\n        attrs: {\r\n            id: `stored-msg-info`,\r\n            text: \"Your last message failed to send and was stored.\",\r\n        }\r\n    },\r\n    loadStorageButton: {\r\n        el: \"button\",\r\n        attrs: {\r\n            class: \"button\",\r\n            ariaLabelledby: `stored-msg-info`,\r\n            text: \"Insert message in form\"\r\n        }\r\n    },\r\n    clearStorageButton: {\r\n        el: \"button\",\r\n        attrs: {\r\n            class: \"button\",\r\n            ariaLabelledby: `stored-msg-info`,\r\n            text: \"Remove message from storage\"\r\n        }\r\n    }\r\n};\r\n\r\nfunction getMessageByStatusCode(statusMessages, statusCode) {\r\n    const message = statusMessages[statusCode] ?? statusMessages[500];\r\n    const messageType = statusCode === 200 ? \"success\" : \"warning\";\r\n\r\n    return [message, messageType];\r\n}\r\n\r\n// TODO:\r\n// * Add retry-timer.\r\n// * Do after form interaction.\r\nasync function initForm(formEl) {\r\n    const notifier = new _codebundlesbyvik_simple_notifier__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\r\n    notifier.init();\r\n\r\n    const formMc = new (_form_mc_form_mc_controller__WEBPACK_IMPORTED_MODULE_1___default())({ formEl });\r\n\r\n    try {\r\n        await formMc.init();\r\n    } catch (error) {\r\n        throw error instanceof Error ? error : new Error(\"initForm(): Unknown form-mc initialization error!\");\r\n    }\r\n\r\n    const elsToEnable = formEl.querySelectorAll(\".js-enable:disabled\");\r\n    elsToEnable.forEach((el) => el.removeAttribute(\"disabled\"));\r\n\r\n    if (localStorage.getItem(`${formEl.name}-data`)) {\r\n        makeStorageEls(formEl, FORM_MSG_STORED_EL_SKELETONS, notifier);\r\n    }\r\n\r\n    const submitInputEl = formEl.querySelector(\"[type=submit]\");\r\n    submitInputEl.addEventListener(\"click\", (e) => submitForm(e, notifier));\r\n}\r\n\r\nlet formDataClearTimeout;\r\n\r\nasync function submitForm(e, notifier) {\r\n    e.preventDefault();\r\n\r\n    if (formDataClearTimeout) {\r\n        clearTimeout(formDataClearTimeout);\r\n    }\r\n\r\n    const formEl = e.target.form;\r\n    const formData = new FormData(formEl);\r\n    const formSendResponse = await sendForm(formData);\r\n    console.log(formSendResponse);\r\n\r\n    if (formSendResponse.status === 200) {\r\n        console.log(\"submitForm(): Form sent successfully.\");\r\n\r\n        localStorage.removeItem(`${formEl.name}-data`);\r\n        formDataClearTimeout = setTimeout(clearForm, 3000, formEl);\r\n    }\r\n\r\n    // DEBUGGING VALUES\r\n    if ((formSendResponse.status === 502 || formSendResponse instanceof Error) && formSendResponse.data) {\r\n        console.log(\"submitForm(): Storing form data...\");\r\n\r\n        storeFormData(formEl.name, formSendResponse.data);\r\n    }\r\n\r\n    // TODO: Send 2 notifications if alertMessage is an array.\r\n    const [alertMessage, alertType] = getMessageByStatusCode(USER_STATUS_MESSAGES, formSendResponse.status);\r\n    notifier.show(alertMessage, alertType);\r\n}\r\n\r\nasync function sendForm(formData) {\r\n    try {\r\n        const response = await fetch(\"./components/form/form-controller.php\", {\r\n            method: \"POST\",\r\n            body: formData,\r\n        });\r\n        console.log(response);\r\n\r\n        // TODO: Handle !response.ok.\r\n\r\n        const contentType = response.headers.get(\"Content-Type\");\r\n\r\n        if (!contentType.includes(\"application/json\")) {\r\n            // TODO: Handle case.\r\n\r\n            throw new Error(\"sendForm(): Response type invalid.\");\r\n        }\r\n\r\n        const data = await response.json();\r\n        console.log(data);\r\n\r\n        return { status: response.status, data };\r\n    } catch (error) {\r\n        throw error instanceof Error ? error : new Error(\"sendForm(): Unknown error!\");\r\n    }\r\n}\r\n\r\nfunction clearForm(formEl) {\r\n    const inputEls = formEl.querySelectorAll(\"input:not([type=button], [type=reset], [type=submit]), textarea\");\r\n    console.log(inputEls);\r\n\r\n    inputEls.forEach((input) => input.value = \"\");\r\n}\r\n\r\nfunction storeFormData(formName, formData) {\r\n    console.log(`storeFormData - formName: ${formName}`);\r\n    console.log(`storeFormData - formData: ${formData}`);\r\n\r\n    const key = `${formName}-data`;\r\n    const value = JSON.stringify(formData);\r\n    localStorage.setItem(key, value);\r\n}\r\n\r\nfunction loadStoredFormData(formEl) {\r\n    const storageItem = localStorage.getItem(`${formEl.name}-data`);\r\n    const formData = JSON.parse(storageItem);\r\n    console.log(`loadStoredFormData - formData: ${formData}`);\r\n\r\n    const inputElList = document.querySelectorAll(\r\n        `[name=${formEl.name}] input:not([type=button], [type=reset], [type=submit]),\r\n         [name=${formEl.name}] textarea`\r\n    );\r\n    const inputEls = Array.prototype.slice.call(inputElList);\r\n    console.log(`loadStoredFormData - inputEls:`);\r\n    console.log(inputEls);\r\n\r\n    Object.keys(formData).map((inputName) => {\r\n        inputEls.map((input) => input.name === inputName ? input.value = formData[inputName] : false);\r\n    });\r\n}\r\n\r\nfunction makeStorageEls(formEl, elSkeletons, notifier) {\r\n    elSkeletons = getStoredFormDataElSkeletons(formEl.name, elSkeletons);\r\n    const els = _helpers_js_create_els__WEBPACK_IMPORTED_MODULE_0___default()(elSkeletons);\r\n\r\n    els.field.appendChild(els.explainer);\r\n    els.field.appendChild(els.loadStorageButton);\r\n    els.field.appendChild(els.clearStorageButton);\r\n    els.fieldset.appendChild(els.field);\r\n    formEl.insertBefore(els.fieldset, formEl.firstElementChild);\r\n\r\n    els.loadStorageButton.addEventListener(\"click\", () => loadStoredFormData(formEl));\r\n    els.clearStorageButton.addEventListener(\"click\", () => {\r\n        localStorage.removeItem(`${formEl.name}-data`);\r\n        notifier.show(\"The stored message has been removed.\", \"info\");\r\n        setTimeout(() => els.fieldset.remove(), 3500);\r\n    });\r\n}\r\n\r\nfunction getStoredFormDataElSkeletons(formName, elSkeletons) {\r\n    const PROPS_TO_MODIFY = {\r\n        explainer: \"id\",\r\n        loadStorageButton: \"ariaLabelledby\",\r\n        clearStorageButton: \"ariaLabelledby\"\r\n    };\r\n\r\n    let modifiedSkeletons = {...elSkeletons};\r\n\r\n    for (const [elName, skeleton] of Object.entries(modifiedSkeletons)) {\r\n        if (Object.getOwnPropertyNames(PROPS_TO_MODIFY).includes(elName)) {\r\n            skeleton.attrs[PROPS_TO_MODIFY[elName]] = `${formName}-${skeleton.attrs[elName]}`;\r\n        }\r\n    }\r\n\r\n    console.log(modifiedSkeletons);\r\n    return modifiedSkeletons;\r\n}\r\n\n\n//# sourceURL=webpack://viktor-web/./components/form/form-controller.js?");

/***/ }),

/***/ "./node_modules/@codebundlesbyvik/element-operations/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@codebundlesbyvik/element-operations/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ createEl)\n/* harmony export */ });\nfunction createEl(tagName, attrs) {\r\n    const el = document.createElement(tagName);\r\n\r\n    if (attrs) {\r\n        for (let [prop, val] of Object.entries(attrs)) {\r\n            prop = prop.replace(/[A-Z0-9]/g, letter => `-${letter.toLowerCase()}`);\r\n\r\n            el.setAttribute(prop, val);\r\n        }\r\n    }\r\n\r\n    return el;\r\n}\r\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/@codebundlesbyvik/element-operations/index.js?");

/***/ }),

/***/ "./node_modules/@codebundlesbyvik/html-dev-label/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codebundlesbyvik/html-dev-label/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ htmlDevLabel)\n/* harmony export */ });\n/* harmony import */ var _codebundlesbyvik_element_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codebundlesbyvik/element-operations */ \"./node_modules/@codebundlesbyvik/element-operations/index.js\");\n\n\nfunction htmlDevLabel(position) {\n    if (false) {}\n\n    let el = document.querySelector(\"#html-dev-label\");\n\n    if (el) {\n        console.warn(\"html-dev-label: Exiting - label already active.\");\n\n        return;\n    }\n\n    el = (0,_codebundlesbyvik_element_operations__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", { id: \"html-dev-label\" });\n\n    el.textContent = \"Build: dev\";\n\n    const positionArray = position ? position.toLowerCase().split(\" \") : \"bottom right\";\n    const positionY = positionArray[0] === \"top\" ? \"top: 0.25rem;\" : \"bottom: 0.25rem;\";\n    const positionX = positionArray[1] === \"left\" ? \"left: 0.25rem;\" : \"right: 0.25rem;\";\n\n    const elCss = `\n        position: fixed; ${positionY} ${positionX} z-index: 10000;\n        padding: 1rem;\n        text-transform: uppercase; font: 700 1.25rem system-ui, -apple-system, \"Segoe UI\", Roboto, \"Helvetica Neue\", \"Noto Sans\", \"Liberation Sans\", Arial, sans-serif;\n        background-color: white; border: 0.25rem solid red;\n    `;\n    el.style.cssText = elCss;\n\n    document.body.insertBefore(el, document.body.firstElementChild);\n}\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/@codebundlesbyvik/html-dev-label/index.js?");

/***/ }),

/***/ "./node_modules/@codebundlesbyvik/number-operations/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@codebundlesbyvik/number-operations/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getRandomIntUnder)\n/* harmony export */ });\n// Get a random integer under a given number.\r\nfunction getRandomIntUnder(max, includeMax) {\r\n    const int = includeMax === true ? 0 : 1;\r\n\r\n    return Math.floor(Math.random() * (max - int));\r\n}\r\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/@codebundlesbyvik/number-operations/index.js?");

/***/ }),

/***/ "./node_modules/@codebundlesbyvik/simple-notifier/dist/js/simple-notifier.esm.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@codebundlesbyvik/simple-notifier/dist/js/simple-notifier.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _codebundlesbyvik_css_operations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codebundlesbyvik/css-operations */ \"./node_modules/@codebundlesbyvik/css-operations/index.js\");\n/* harmony import */ var _codebundlesbyvik_element_operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codebundlesbyvik/element-operations */ \"./node_modules/@codebundlesbyvik/element-operations/index.js\");\n/* harmony import */ var _codebundlesbyvik_number_operations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codebundlesbyvik/number-operations */ \"./node_modules/@codebundlesbyvik/number-operations/index.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst mergeOptions = __webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.js\");\n\n\n\n\nconst defaultOptions = {\n  autoHide: true,\n  // Number / Boolean\n  onlyOneNotification: true,\n  // Boolean\n  parentEl: document.body,\n  // Element\n  position: \"top center\",\n  // String\n  animations: \"auto\" // String / Boolean\n\n};\n\nclass SN {\n  constructor() {\n    let userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.mergedOptions = mergeOptions(defaultOptions, userOptions);\n    this.autoHide = this.mergedOptions.autoHide;\n    this.parentEl = this.mergedOptions.parentEl;\n    this.position = this.mergedOptions.position;\n    this.motionPref = this.mergedOptions.animations;\n    this.instanceId = null;\n    this.nId = 1;\n    this.nodes = {};\n    this.msgData = {};\n    this.timeoutIds = {};\n    this.events = {};\n    this.onlyOne = {\n      set: this.mergedOptions.onlyOneNotification,\n      states: {},\n      nextMsgData: {}\n    };\n    this.animatedRun = null;\n  }\n\n  get animated() {\n    switch (this.motionPref) {\n      case \"undefined\":\n      case \"auto\":\n        return (0,_codebundlesbyvik_css_operations__WEBPACK_IMPORTED_MODULE_0__.motionAllowed)();\n\n      default:\n        return this.motionPref;\n    }\n  }\n\n  get hideCallTimeout() {\n    switch (this.autoHide) {\n      case true:\n        return 3500;\n\n      case false:\n        return 0;\n\n      default:\n        return this.autoHide;\n    }\n  }\n\n  init() {\n    if (this.instanceId) {\n      throw new Error(\"SN: .init() has already been called on this instance (\".concat(this.instanceId, \").\"));\n    }\n\n    this.instanceId = (0,_codebundlesbyvik_number_operations__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(100000);\n    this.nodes.wrapper = (0,_codebundlesbyvik_element_operations__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(SN.nodeSkeletons.wrapper.tagName, SN.nodeSkeletons.wrapper.attrs);\n    this.nodes.wrapper.dataset.instanceId = this.instanceId;\n    const parentElFChild = this.parentEl.firstElementChild; // Insert the instance in the DOM after any earlier initialized instances sharing the same parentEl.\n\n    const siblingEl = parentElFChild.classList.contains(\"simple-notifier\") ? parentElFChild.nextElementSibling : parentElFChild;\n    this.parentEl.insertBefore(this.nodes.wrapper, siblingEl);\n    const screenPosArray = this.position.split(\" \"); // If only a y-position is set by the user, add an x-position.\n\n    if (screenPosArray.length === 1) {\n      screenPosArray[1] = \"center\";\n    }\n\n    this.nodes.wrapper.classList.add(\"\".concat(SN.nodeClasses.wrapper, \"--pos-y-\").concat(screenPosArray[0]), \"\".concat(SN.nodeClasses.wrapper, \"--pos-x-\").concat(screenPosArray[1]));\n    this.events.allDestroyed = new CustomEvent(\"allNotificationsDestroyed\", {\n      detail: {\n        instanceId: this.instanceId\n      }\n    });\n  }\n\n  destroy() {\n    if (!this.instanceId) {\n      throw new Error(\"SN: Instance isn't initialized!\");\n    }\n\n    if (this.runningDestroy) {\n      return;\n    }\n\n    this.runningDestroy = true;\n    this.nodes.wrapper.addEventListener(\"allNotificationsDestroyed\", e => {\n      this.nodes.wrapper.remove();\n\n      if (this.onlyOne) {\n        this.onlyOne.states = {};\n        this.onlyOne.nextMsgData = {};\n      }\n\n      this.events = {};\n      this.nId = 1;\n      this.instanceId = null;\n      delete this.runningDestroy;\n    });\n    this.hide();\n  }\n\n  show(text, type) {\n    if (!this.instanceId) {\n      throw new Error(\"SN: Instance isn't initialized!\");\n    }\n\n    if (this.onlyOne.set) {\n      if (this.onlyOne.states.inReshow) {\n        return;\n      }\n\n      if (this.onlyOne.states.isVisible) {\n        this._reshowNotification(text, type);\n\n        return;\n      }\n    }\n\n    let nId = this.nId;\n\n    if (!this.onlyOne.set) {\n      this.nId++;\n    }\n\n    this._initNotification(nId);\n\n    this._getMsgData(nId, text, type);\n\n    this._showNewNotification(nId);\n  }\n\n  _initNotification(nId) {\n    this.nodes[nId] = {};\n\n    for (const [role, values] of Object.entries(SN.nodeSkeletons)) {\n      if (role === \"wrapper\") continue;\n      this.nodes[nId][role] = (0,_codebundlesbyvik_element_operations__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(values.tagName, values.attrs);\n\n      if (role === \"notification\") {\n        this.nodes.wrapper.insertBefore(this.nodes[nId][role], this.nodes.wrapper.firstElementChild);\n      } else {\n        this.nodes[nId].notification.append(this.nodes[nId][role]);\n      }\n    }\n\n    this.nodes[nId].notification.dataset.notificationId = nId;\n    this.timeoutIds[nId] = {};\n    this.events[nId] = {};\n    this.events[nId].shown = new CustomEvent(\"notificationShown\", {\n      detail: {\n        instanceId: this.instanceId,\n        notificationId: nId\n      }\n    });\n    this.events[nId].destroyed = new CustomEvent(\"notificationDestroyed\", {\n      detail: {\n        instanceId: this.instanceId,\n        notificationId: nId\n      }\n    });\n    this.nodes.wrapper.addEventListener(\"notificationShown\", this.events[nId].shown, {\n      once: true\n    });\n    this.nodes.wrapper.addEventListener(\"notificationDestroyed\", this.events[nId].destroyed, {\n      once: true\n    });\n  }\n\n  _getMsgData(nId, text, type) {\n    if (!nId) {\n      return;\n    }\n\n    if (!text) {\n      if (this.onlyOne.nextMsgData) {\n        text = this.onlyOne.nextMsgData.text;\n        type = this.onlyOne.nextMsgData.type;\n        this.onlyOne.nextMsgData = {};\n      } else {\n        text = SN.defaultMsgData.notext.text;\n        type = SN.defaultMsgData.notext.type;\n      }\n    }\n\n    if (!type) {\n      type = SN.defaultMsgData.notype.type;\n    }\n\n    this.msgData[nId] = {};\n    this.msgData[nId].text = text;\n    this.msgData[nId].type = type;\n  }\n\n  _showNewNotification(nId) {\n    this.animatedRun = this.animated;\n    this.nodes[nId].message.textContent = this.msgData[nId].text;\n    this.nodes[nId].notification.classList.add(\"\".concat(SN.nodeClasses.notification, \"--\").concat(this.msgData[nId].type), SN.nodeClasses.shown);\n\n    if (this.animatedRun) {\n      this.nodes[nId].notification.classList.add(SN.nodeClasses.anim.base, SN.nodeClasses.anim.show);\n      const animTimeout = (0,_codebundlesbyvik_css_operations__WEBPACK_IMPORTED_MODULE_0__.timeToMs)((0,_codebundlesbyvik_css_operations__WEBPACK_IMPORTED_MODULE_0__.getPropValue)(this.nodes[nId].notification, \"animation-duration\"));\n      this.timeoutIds[nId].showAnim = setTimeout(() => {\n        this.nodes[nId].notification.classList.remove(SN.nodeClasses.anim.show);\n      }, animTimeout);\n    }\n\n    if (this.onlyOne.set) {\n      this.onlyOne.states.isVisible = true;\n    }\n\n    this.nodes.wrapper.dispatchEvent(this.events[nId].shown);\n\n    if (this.hideCallTimeout > 0) {\n      this.timeoutIds[nId].hideCall = setTimeout(() => {\n        this.hide(nId);\n      }, this.hideCallTimeout);\n    } else {\n      this.animatedRun = null;\n    }\n  }\n\n  _reshowNotification(text, type) {\n    this.onlyOne.states.inReshow = true;\n    this.onlyOne.nextMsgData.text = text;\n    this.onlyOne.nextMsgData.type = type;\n    clearTimeout(this.timeoutIds[1].hideCall);\n    this.hide(1);\n  }\n\n  hide(nId) {\n    if (!this.instanceId) {\n      throw new Error(\"SN: Instance isn't initialized!\");\n    }\n\n    if (this.onlyOne.set) {\n      if (this.onlyOne.states.inHide) {\n        return;\n      }\n\n      this.onlyOne.states.inHide = true;\n    }\n\n    let nIdsArray;\n\n    if (typeof nId === \"number\") {\n      if (this.msgData[nId] === \"undefined\") {\n        return;\n      }\n\n      nIdsArray = [nId];\n    }\n\n    if (typeof nId === \"undefined\") {\n      nIdsArray = Object.keys(this.msgData);\n\n      if (nIdsArray.length > 0) {\n        Object.values(this.timeoutIds).forEach(nTimeoutIds => {\n          Object.values(nTimeoutIds).forEach(timeoutId => {\n            clearTimeout(timeoutId);\n          });\n        });\n      } else if (this.runningDestroy) {\n        this.nodes.wrapper.dispatchEvent(this.events.allDestroyed);\n      } else {\n        if (this.onlyOne.set) {\n          this.onlyOne.states.inHide = false;\n        }\n\n        return;\n      }\n    }\n\n    nIdsArray.forEach(id => {\n      this._hideNotification(id);\n    });\n\n    if (this.onlyOne.set) {\n      this.onlyOne.states.inHide = false;\n    }\n  }\n\n  _hideNotification(nId) {\n    if (this.animatedRun === null) {\n      this.animatedRun = this.animated;\n    }\n\n    let animTimeout = 0;\n\n    if (this.animatedRun) {\n      this.nodes[nId].notification.classList.add(SN.nodeClasses.anim.hide);\n      animTimeout = (0,_codebundlesbyvik_css_operations__WEBPACK_IMPORTED_MODULE_0__.timeToMs)((0,_codebundlesbyvik_css_operations__WEBPACK_IMPORTED_MODULE_0__.getPropValue)(this.nodes[nId].notification, \"animation-duration\"));\n    }\n\n    this.timeoutIds[nId].hideAnim = setTimeout(() => {\n      this.nodes[nId].notification.classList.remove(SN.nodeClasses.shown);\n      this.nodes[nId].notification.className = this.nodes[nId].notification.className.replace(SN.nodeClasses.typeRegex, \"\");\n\n      if (this.animatedRun) {\n        this.nodes[nId].notification.classList.remove(SN.nodeClasses.anim.hide);\n      }\n\n      if (this.onlyOne.set) {\n        this.onlyOne.states.isVisible = false;\n      }\n\n      this._destroyNotification(nId);\n    }, animTimeout);\n  }\n\n  _destroyNotification(nId) {\n    const nodesArrayKeys = Object.keys(this.nodes[nId]);\n    const nodesArrayValues = Object.values(this.nodes[nId]);\n    new Promise(resolve => {\n      let nodeKey = 0;\n      nodesArrayValues.forEach(node => {\n        node.remove();\n        nodeKey++;\n\n        if (nodeKey === nodesArrayKeys.length) {\n          resolve(\"All nodes have succesfully been removed.\");\n        }\n      });\n    }).then(() => {\n      this.animatedRun = null;\n      delete this.nodes[nId];\n      delete this.msgData[nId];\n      delete this.timeoutIds[nId];\n      this.nodes.wrapper.dispatchEvent(this.events[nId].destroyed);\n      delete this.events[nId];\n\n      if (Object.keys(this.msgData).length === 0) {\n        this.nodes.wrapper.dispatchEvent(this.events.allDestroyed);\n      }\n\n      if (this.onlyOne.set && this.onlyOne.states.inReshow) {\n        this.onlyOne.states.inReshow = false;\n        this.show();\n      }\n    }).catch(error => {\n      throw new Error(error);\n    });\n  }\n\n}\n\n_defineProperty(SN, \"nodeClasses\", {\n  wrapper: \"simple-notifier\",\n  notification: \"simple-notification\",\n  typeRegex: /simple-notification--[A-Za-z]+/g,\n  shown: \"is-shown\",\n  anim: {\n    base: \"animated\",\n    show: \"fadeIn\",\n    hide: \"fadeOut\"\n  }\n});\n\n_defineProperty(SN, \"nodeSkeletons\", {\n  wrapper: {\n    tagName: \"div\",\n    attrs: {\n      class: SN.nodeClasses.wrapper\n    }\n  },\n  notification: {\n    tagName: \"div\",\n    attrs: {\n      class: SN.nodeClasses.notification,\n      role: \"alert\"\n    }\n  },\n  message: {\n    tagName: \"p\",\n    attrs: {\n      class: \"\".concat(SN.nodeClasses.notification, \"__message\")\n    }\n  }\n});\n\n_defineProperty(SN, \"defaultMsgData\", {\n  notext: {\n    text: \"This is some dummy text for you, because none was passed in.\",\n    type: \"debug\"\n  },\n  notype: {\n    type: \"default\"\n  }\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SN);\n\n//# sourceMappingURL=simple-notifier.esm.js.map\n\n//# sourceURL=webpack://viktor-web/./node_modules/@codebundlesbyvik/simple-notifier/dist/js/simple-notifier.esm.js?");

/***/ }),

/***/ "./node_modules/is-plain-obj/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-plain-obj/index.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/is-plain-obj/index.js?");

/***/ }),

/***/ "./node_modules/merge-options/index.js":
/*!*********************************************!*\
  !*** ./node_modules/merge-options/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nconst isOptionObject = __webpack_require__(/*! is-plain-obj */ \"./node_modules/is-plain-obj/index.js\");\n\nconst {hasOwnProperty} = Object.prototype;\nconst {propertyIsEnumerable} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n\tvalue,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true\n});\n\nconst globalThis = this;\nconst defaultMergeOptions = {\n\tconcatArrays: false,\n\tignoreUndefined: false\n};\n\nconst getEnumerableOwnPropertyKeys = value => {\n\tconst keys = [];\n\n\tfor (const key in value) {\n\t\tif (hasOwnProperty.call(value, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\n\t/* istanbul ignore else  */\n\tif (Object.getOwnPropertySymbols) {\n\t\tconst symbols = Object.getOwnPropertySymbols(value);\n\n\t\tfor (const symbol of symbols) {\n\t\t\tif (propertyIsEnumerable.call(value, symbol)) {\n\t\t\t\tkeys.push(symbol);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keys;\n};\n\nfunction clone(value) {\n\tif (Array.isArray(value)) {\n\t\treturn cloneArray(value);\n\t}\n\n\tif (isOptionObject(value)) {\n\t\treturn cloneOptionObject(value);\n\t}\n\n\treturn value;\n}\n\nfunction cloneArray(array) {\n\tconst result = array.slice(0, 0);\n\n\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\n\t\tdefineProperty(result, key, clone(array[key]));\n\t});\n\n\treturn result;\n}\n\nfunction cloneOptionObject(object) {\n\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n\n\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\n\t\tdefineProperty(result, key, clone(object[key]));\n\t});\n\n\treturn result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n\tkeys.forEach(key => {\n\t\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not recurse into prototype chain of merged\n\t\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n\t\t\tdefineProperty(merged, key, merge(merged[key], source[key], config));\n\t\t} else {\n\t\t\tdefineProperty(merged, key, clone(source[key]));\n\t\t}\n\t});\n\n\treturn merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n\tlet result = merged.slice(0, 0);\n\tlet resultIndex = 0;\n\n\t[merged, source].forEach(array => {\n\t\tconst indices = [];\n\n\t\t// `result.concat(array)` with cloning\n\t\tfor (let k = 0; k < array.length; k++) {\n\t\t\tif (!hasOwnProperty.call(array, k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindices.push(String(k));\n\n\t\t\tif (array === merged) {\n\t\t\t\t// Already cloned\n\t\t\t\tdefineProperty(result, resultIndex++, array[k]);\n\t\t\t} else {\n\t\t\t\tdefineProperty(result, resultIndex++, clone(array[k]));\n\t\t\t}\n\t\t}\n\n\t\t// Merge non-index keys\n\t\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n\t});\n\n\treturn result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n\t\treturn concatArrays(merged, source, config);\n\t}\n\n\tif (!isOptionObject(source) || !isOptionObject(merged)) {\n\t\treturn clone(source);\n\t}\n\n\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\n\nmodule.exports = function (...options) {\n\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\n\tlet merged = {_: {}};\n\n\tfor (const option of options) {\n\t\tif (option === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isOptionObject(option)) {\n\t\t\tthrow new TypeError('`' + option + '` is not an Option Object');\n\t\t}\n\n\t\tmerged = merge(merged, {_: option}, config);\n\t}\n\n\treturn merged._;\n};\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/merge-options/index.js?");

/***/ }),

/***/ "./sass/style.scss":
/*!*************************!*\
  !*** ./sass/style.scss ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://viktor-web/./sass/style.scss?");

/***/ }),

/***/ "./components/about-me/typeit.ts":
/*!***************************************!*\
  !*** ./components/about-me/typeit.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeit_1 = __importDefault(__webpack_require__(/*! typeit */ \"./node_modules/typeit/dist/index.es.js\"));\nfunction initTypeItAboutMe(targetEl) {\n    if (!targetEl) {\n        console.error(\"initTypeItAboutMe(): Aborting initialization - targetEl undefined or not found!\");\n        return;\n    }\n    const options = {\n        speed: 75,\n        deleteSpeed: 40,\n        loop: true\n    };\n    const instance = new typeit_1.default(targetEl, options)\n        //\n        .type(\"Photographer\", { delay: 1800 })\n        .delete(null, { delay: 1000 })\n        //\n        .type(\"Web devlo\", { delay: 500 })\n        .move(-2, { speed: 150, delay: 350 })\n        .type(\"e\", { delay: 500 })\n        .move(2, { speed: 100, delay: 400 })\n        .type(\"per\", { delay: 1850 })\n        .delete(null, { delay: 1000 })\n        //\n        .type(\"Moti\", { delay: 400 })\n        .delete(2, { speed: 120, delay: 350 })\n        .type(\"toring enthusiast\", { delay: 2000 })\n        .delete(null, { delay: 900 })\n        //\n        .type(\"Human\", { delay: 1450 })\n        .delete(null, { delay: 900 })\n        //\n        .go();\n    return instance;\n}\nexports[\"default\"] = initTypeItAboutMe;\n\n\n//# sourceURL=webpack://viktor-web/./components/about-me/typeit.ts?");

/***/ }),

/***/ "./components/form-mc/form-mc-controller.ts":
/*!**************************************************!*\
  !*** ./components/form-mc/form-mc-controller.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst merge_options_1 = __importDefault(__webpack_require__(/*! merge-options */ \"./node_modules/merge-options/index.js\"));\nconst create_el_1 = __importDefault(__webpack_require__(/*! ../../helpers/js/create-el */ \"./helpers/js/create-el.ts\"));\nconst fetch_with_timeout_1 = __importDefault(__webpack_require__(/*! ../../helpers/js/fetch-with-timeout */ \"./helpers/js/fetch-with-timeout.ts\"));\nconst time_sync_1 = __importDefault(__webpack_require__(/*! ../time-sync/time-sync */ \"./components/time-sync/time-sync.ts\"));\nconst set_timeout_promise_1 = __importDefault(__webpack_require__(/*! ../../helpers/js/set-timeout-promise */ \"./helpers/js/set-timeout-promise.ts\"));\nconst DEFAULT_OPTIONS = {\n    makeProblemRetryTimesMs: [3000, 5000, 8000],\n};\nclass FormMc {\n    makeProblemRetryTimesMs;\n    formEl;\n    inputElWrapper;\n    inputEl;\n    labelEl;\n    loaderEl;\n    initButtonEl;\n    canLoop;\n    loopTryCountTotal;\n    loopConcurrentTryCount;\n    prevClientOffsetMs;\n    inputInFocusBeforeRefresh;\n    constructor(userOptions) {\n        const mergedOptions = merge_options_1.default.apply({ ignoreUndefined: true }, [DEFAULT_OPTIONS, userOptions]);\n        this.makeProblemRetryTimesMs = mergedOptions.makeProblemRetryTimesMs;\n        this.formEl = mergedOptions.formEl;\n        this.inputElWrapper = null;\n        this.inputEl = null;\n        this.labelEl = (0, create_el_1.default)(\"label\");\n        this.loaderEl = (0, create_el_1.default)(\"div\", {\n            class: \"spinner\",\n            style: \"font-size: 1.5rem;\",\n        });\n        this.initButtonEl = (0, create_el_1.default)(\"button\", {\n            type: \"button\",\n            text: \"Activate\",\n        });\n        this.canLoop = false;\n        this.loopTryCountTotal = 0;\n        this.loopConcurrentTryCount = 0;\n        this.prevClientOffsetMs = null;\n        this.inputInFocusBeforeRefresh = false;\n        this.initButtonEl.addEventListener(\"click\", this.handleInitButtonPress.bind(this));\n    }\n    static STATE_MESSAGES_USER = {\n        deactivated: \"CAPTCHA deactivated.\",\n        error: \"CAPTCHA error. Please reload the page.\",\n    };\n    showLoader = () => this.inputEl && document.body.contains(this.inputEl)\n        ? this.inputEl.after(this.loaderEl)\n        : this.inputElWrapper\n            ? this.inputElWrapper.appendChild(this.loaderEl)\n            : undefined;\n    hideLoader = () => this.loaderEl.remove();\n    async handleInitButtonPress() {\n        this.initButtonEl.remove();\n        await this.init();\n    }\n    async init() {\n        console.log(\"FormMc init(): Running...\");\n        try {\n            this.assignInputEl();\n            this.canLoop = true;\n            await this.problemLoopHandler();\n        }\n        catch (error) {\n            throw error instanceof Error\n                ? error\n                : new Error(\"FormMc init(): Failed to initialize!\");\n        }\n    }\n    deactivate(reactivatable) {\n        console.log(\"FormMc deactivate(): Running...\");\n        // Return if already deactivated.\n        if (!this.canLoop)\n            return;\n        console.log(`FormMc deactivate(): CAPTCHA ${reactivatable ? \"may be\" : \"may NOT be\"} reactivated.`);\n        this.canLoop = false;\n        if (this.inputEl) {\n            this.inputEl.remove();\n        }\n        if (!document.body.contains(this.labelEl) && this.inputElWrapper) {\n            this.inputElWrapper.insertBefore(this.labelEl, this.inputElWrapper.firstChild);\n        }\n        if (!document.body.contains(this.labelEl))\n            return;\n        if (reactivatable) {\n            this.labelEl.textContent = FormMc.STATE_MESSAGES_USER.deactivated;\n            this.labelEl.after(this.initButtonEl);\n        }\n        else {\n            this.labelEl.textContent = FormMc.STATE_MESSAGES_USER.error;\n        }\n    }\n    assignInputEl() {\n        try {\n            if (!this.inputEl) {\n                this.inputEl = this.formEl.querySelector(\"[name=cf-mc]\");\n                if (!this.inputEl) {\n                    throw new Error(\"FormMc init(): <input> not found!\");\n                }\n                this.inputElWrapper = this.inputEl.parentElement;\n            }\n        }\n        catch (error) {\n            this.deactivate(false);\n            throw error instanceof Error\n                ? error\n                : new Error(\"FormMc assignInputEl(): Unknown error!\");\n        }\n    }\n    async getProblem() {\n        console.log(\"FormMc getProblem(): Running...\");\n        try {\n            const response = await (0, fetch_with_timeout_1.default)({\n                resource: \"./components/form-mc/form-mc-generator.php\",\n            });\n            console.log(response);\n            if (!response.ok) {\n                throw new Error(`FormMc getProblem() - fetch failed: ${response.status} ${response.statusText}`);\n            }\n            const problem = await response.json();\n            console.log(`FormMc getProblem() - problem: ${problem}`);\n            return problem;\n        }\n        catch (error) {\n            throw error instanceof Error ? error : new Error(\"FormMc getProblem(): Unknown error!\");\n        }\n    }\n    async makeProblem() {\n        console.log(\"FormMc makeProblem(): Running...\");\n        try {\n            const dateSyncValues = await (0, time_sync_1.default)(this.prevClientOffsetMs, 8, 5);\n            this.prevClientOffsetMs = dateSyncValues.clientOffsetMs;\n            const correctedDateMs = dateSyncValues.correctedDateMs;\n            const [digit1, digit2, invalidAfterTime] = await this.getProblem();\n            const timeToRefresh = Math.ceil(Math.max(invalidAfterTime - correctedDateMs, 0));\n            const problemData = [digit1, digit2, timeToRefresh];\n            console.log(`FormMc makeProblem() - problemData: ${problemData}`);\n            return problemData;\n        }\n        catch (error) {\n            throw error instanceof Error\n                ? error\n                : new Error(\"FormMc makeProblem(): Unknown error!\");\n        }\n    }\n    insertProblem(digit1, digit2) {\n        console.log(\"FormMc insertProblem(): Running...\");\n        try {\n            if (!this.inputEl) {\n                throw new Error(\"FormMc insertProblem(): <input> not found!\");\n            }\n            const labelString = `${digit1} + ${digit2} =`;\n            if (document.body.contains(this.inputEl) && !document.body.contains(this.labelEl)) {\n                this.inputEl.before(this.labelEl);\n            }\n            if (document.body.contains(this.labelEl) && !document.body.contains(this.inputEl)) {\n                this.labelEl.after(this.inputEl);\n            }\n            this.labelEl.textContent = labelString;\n        }\n        catch (error) {\n            this.deactivate(false);\n            throw error instanceof Error\n                ? error\n                : new Error(\"FormMc insertProblem(): Unknown error!\");\n        }\n    }\n    async problemLoopHandler() {\n        while (this.canLoop) {\n            try {\n                this.showLoader();\n                this.loopConcurrentTryCount++;\n                console.log(`FormMc problemLoopHandler() - loopConcurrentTryCount: ${this.loopConcurrentTryCount}`);\n                this.loopTryCountTotal++;\n                console.log(`FormMc problemLoopHandler() - loopTryCountTotal: ${this.loopTryCountTotal}`);\n                if (!this.inputEl) {\n                    throw new Error(\"FormMc problemLoopHandler(): <input> not found!\");\n                }\n                this.inputInFocusBeforeRefresh = this.inputEl === document.activeElement;\n                this.inputEl.disabled = true;\n                const [digit1, digit2, timeToRefresh] = await this.makeProblem();\n                this.insertProblem(digit1, digit2);\n                this.inputEl.disabled = false;\n                if (this.inputInFocusBeforeRefresh)\n                    this.inputEl.focus();\n                this.loopConcurrentTryCount = 0;\n                this.hideLoader(), await (0, set_timeout_promise_1.default)(timeToRefresh);\n            }\n            catch (error) {\n                console.error(error);\n                if (this.loopConcurrentTryCount > this.makeProblemRetryTimesMs.length) {\n                    const errorCause = error instanceof Error && error.cause instanceof Error\n                        ? error.cause.name\n                        : false;\n                    this.deactivate(!!errorCause);\n                    this.hideLoader();\n                    throw new Error(`FormMc problemLoopHandler(): deactivated because generation failed ${this.loopConcurrentTryCount} concurrent times!`);\n                }\n                await (0, set_timeout_promise_1.default)(this.makeProblemRetryTimesMs[Math.max(this.loopConcurrentTryCount - 1, 0)]);\n            }\n        }\n    }\n}\nexports[\"default\"] = FormMc;\n\n\n//# sourceURL=webpack://viktor-web/./components/form-mc/form-mc-controller.ts?");

/***/ }),

/***/ "./components/time-sync/time-sync.ts":
/*!*******************************************!*\
  !*** ./components/time-sync/time-sync.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = void 0;\nconst fetch_with_timeout_1 = __importDefault(__webpack_require__(/*! ../../helpers/js/fetch-with-timeout */ \"./helpers/js/fetch-with-timeout.ts\"));\nconst get_number_array_average_1 = __importDefault(__webpack_require__(/*! ../../helpers/js/get-number-array-average */ \"./helpers/js/get-number-array-average.ts\"));\nconst set_timeout_promise_1 = __importDefault(__webpack_require__(/*! ../../helpers/js/set-timeout-promise */ \"./helpers/js/set-timeout-promise.ts\"));\n// https://stackoverflow.com/a/22969338/6396604\n//\n// NTP\n// t0 is the client's timestamp at the request packet transmission\n// t1 is the server's timestamp at the request packet reception\n// t2 is the server's timestamp at the response packet transmission\n// t3 is the client's timestamp at the response packet reception\nfunction makeNtpObj(t0, t1, t2, t3) {\n    const roundTripDelay = (t3 - t0) - (t2 - t1);\n    const clientOffset = ((t1 - t0) + (t2 - t3)) / 2; // client > server\n    return { roundTripDelay, clientOffset };\n}\nasync function getNtpValues() {\n    console.log(\"getNtpValues(): Running...\");\n    try {\n        const t0ReqTransmitTime = new Date().valueOf();\n        const response = await (0, fetch_with_timeout_1.default)({\n            resource: \"./components/time-sync/ntp.php\",\n            fetchOptions: {\n                method: \"GET\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(`getNtpValues() - fetch failed: ${response.status} ${response.statusText}`);\n        }\n        const t1ReqReceivedTime = await response.json();\n        let t2RespTransmitTime = t1ReqReceivedTime;\n        const t2RespDateMicroHeader = response.headers.get(\"Date-Micro\");\n        if (t2RespDateMicroHeader) {\n            const t2RespTransmitTimeMicro = parseInt(t2RespDateMicroHeader.slice(-1 * (t2RespDateMicroHeader.length - 2)));\n            const t2RespTransmitTimeMilli = Math.round(t2RespTransmitTimeMicro / 1000);\n            t2RespTransmitTime = new Date(t2RespTransmitTimeMilli).valueOf();\n        }\n        const t3RespReceivedTime = new Date().valueOf();\n        console.log(`getNtpValues() - NTP values:\\n\\nt0: ${t0ReqTransmitTime}\\nt1: ${t1ReqReceivedTime}\\nt1: ${t2RespTransmitTime}\\nt3: ${t3RespReceivedTime}`);\n        if ([t0ReqTransmitTime, t1ReqReceivedTime, t2RespTransmitTime, t3RespReceivedTime].some((time) => isNaN(time))) {\n            throw new Error(\"getNtpValues(): Some of the required values aren't of type 'number'.\");\n        }\n        const ntpCalculations = makeNtpObj(t0ReqTransmitTime, t1ReqReceivedTime, t2RespTransmitTime, t3RespReceivedTime);\n        console.log(`getNtpValues():\\n\\nDelay:   ${ntpCalculations.roundTripDelay}\\nOffset: ${ntpCalculations.clientOffset}`);\n        return ntpCalculations;\n    }\n    catch (error) {\n        throw error instanceof Error ? error : new Error(\"getNtpValues(): Unknown error!\");\n    }\n}\nfunction getAverageClientOffset(offsets) {\n    let offsetsFiltered = offsets;\n    if (offsets.length > 2) {\n        const offsetsMin = Math.min(...offsets);\n        const offsetsMax = Math.max(...offsets);\n        offsetsFiltered = offsets.filter((offset) => offset !== offsetsMin && offset !== offsetsMax);\n    }\n    const averageClientOffset = (0, get_number_array_average_1.default)(offsetsFiltered, \"floor\");\n    console.log(`getAverageClientOffset() - averageClientOffset: ${averageClientOffset}`);\n    return averageClientOffset;\n}\nasync function getClientOffsetMs(syncAttempts, requiredSuccesses) {\n    console.log(\"getClientOffsetMs(): Running...\");\n    try {\n        if (syncAttempts < 1) {\n            throw new Error(\"getClientOffsetMs(): syncAttempts cannot be smaller than 1!\");\n        }\n        const offsets = [];\n        for (let runIndex = 0, successfulRunIndex = 0; runIndex < syncAttempts; runIndex++) {\n            console.log(`getClientOffsetMs() - fetch loop runIndex: ${runIndex}`);\n            if (successfulRunIndex > requiredSuccesses - 1)\n                break;\n            try {\n                if (runIndex > requiredSuccesses - 1) {\n                    await (0, set_timeout_promise_1.default)(1000);\n                }\n                const ntpValues = await getNtpValues();\n                offsets[successfulRunIndex] = ntpValues.clientOffset;\n                successfulRunIndex++;\n            }\n            catch (error) {\n                console.warn(`getClientOffsetMs(): Fetch loop run with index ${runIndex} failed!`);\n                // If this is the final attempt and the amount of required successful runs isn't met.\n                if (runIndex === syncAttempts - 1 && successfulRunIndex < requiredSuccesses - 1 &&\n                    error instanceof Error && error.name === \"AbortError\") {\n                    throw new Error(`getClientOffsetMs(): Final sync attempt failed due to a fetch() timeout!`, { cause: error });\n                }\n            }\n        }\n        console.log(`getClientOffsetMs() - offsets:`);\n        console.log(offsets);\n        if (offsets.length < requiredSuccesses) {\n            throw new Error(`getClientOffsetMs(): Didn't meet the amount of ${requiredSuccesses} required successful calculations within the allowed amount of ${syncAttempts} syncAttempts!`);\n        }\n        return getAverageClientOffset(offsets);\n    }\n    catch (error) {\n        throw error instanceof Error ? error : new Error(\"getClientOffsetMs(): Unknown error!\");\n    }\n}\nasync function getDateSyncValues(prevClientOffset, syncAttempts, reqSuccessfulSyncAttempts) {\n    try {\n        let newClientOffsetMs;\n        if (prevClientOffset === null) {\n            newClientOffsetMs = await getClientOffsetMs(syncAttempts, reqSuccessfulSyncAttempts);\n        }\n        else {\n            newClientOffsetMs = await getClientOffsetMs(1, 1);\n            if (prevClientOffset - newClientOffsetMs < -200 ||\n                prevClientOffset - newClientOffsetMs > 200) {\n                console.warn(\"getDateSyncValues(): this.prevClientOffsetMs discrepancy too large!\");\n                newClientOffsetMs = await getClientOffsetMs(syncAttempts, reqSuccessfulSyncAttempts);\n            }\n        }\n        const correctedDateMs = new Date().valueOf() - newClientOffsetMs;\n        console.log(`getDateSyncValues() - correctedDateMs: ${correctedDateMs}`);\n        return { clientOffsetMs: newClientOffsetMs, correctedDateMs };\n    }\n    catch (error) {\n        throw error instanceof Error ? error : new Error(\"getDateSyncValues(): Unknown error!\");\n    }\n}\nexports[\"default\"] = getDateSyncValues;\n\n\n//# sourceURL=webpack://viktor-web/./components/time-sync/time-sync.ts?");

/***/ }),

/***/ "./helpers/js/create-el.ts":
/*!*********************************!*\
  !*** ./helpers/js/create-el.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction createEl(tagName, attrs) {\n    const el = document.createElement(tagName);\n    if (attrs) {\n        if (typeof attrs === \"string\") {\n            el.className = attrs;\n        }\n        else {\n            for (const [prop, val] of Object.entries(attrs)) {\n                if (prop === \"text\") {\n                    el.innerText = val;\n                    continue;\n                }\n                const propKebab = prop.replace(/[A-Z0-9]/g, letter => `-${letter.toLowerCase()}`);\n                el.setAttribute(propKebab, val);\n            }\n        }\n    }\n    return el;\n}\nexports[\"default\"] = createEl;\n\n\n//# sourceURL=webpack://viktor-web/./helpers/js/create-el.ts?");

/***/ }),

/***/ "./helpers/js/create-els.ts":
/*!**********************************!*\
  !*** ./helpers/js/create-els.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst create_el_1 = __importDefault(__webpack_require__(/*! ./create-el */ \"./helpers/js/create-el.ts\"));\nfunction createEls(elSkeletons) {\n    const createdEls = {};\n    for (const [name, skeleton] of Object.entries(elSkeletons)) {\n        const createdEl = (0, create_el_1.default)(skeleton.el, skeleton.attrs);\n        createdEls[name] = createdEl;\n    }\n    return createdEls;\n}\nexports[\"default\"] = createEls;\n\n\n//# sourceURL=webpack://viktor-web/./helpers/js/create-els.ts?");

/***/ }),

/***/ "./helpers/js/fetch-with-timeout.ts":
/*!******************************************!*\
  !*** ./helpers/js/fetch-with-timeout.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function fetchWithTimeout({ resource, fetchOptions, timeout }) {\n    if (!timeout) {\n        timeout = 8000;\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n    const response = await fetch(resource, {\n        ...(fetchOptions || {}),\n        signal: controller.signal\n    });\n    clearTimeout(timeoutId);\n    return response;\n}\nexports[\"default\"] = fetchWithTimeout;\n\n\n//# sourceURL=webpack://viktor-web/./helpers/js/fetch-with-timeout.ts?");

/***/ }),

/***/ "./helpers/js/get-number-array-average.ts":
/*!************************************************!*\
  !*** ./helpers/js/get-number-array-average.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction getNumberArrayAverage(array, round = false) {\n    const average = array.reduce((prev, cur) => prev + cur, 0) / array.length;\n    switch (round) {\n        case \"floor\":\n            return Math.floor(average);\n        case \"ceil\":\n            return Math.ceil(average);\n        default:\n            return average;\n    }\n}\nexports[\"default\"] = getNumberArrayAverage;\n\n\n//# sourceURL=webpack://viktor-web/./helpers/js/get-number-array-average.ts?");

/***/ }),

/***/ "./helpers/js/mouse-input-detector.ts":
/*!********************************************!*\
  !*** ./helpers/js/mouse-input-detector.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction initMouseInputDetector(targetEl) {\n    if (!targetEl) {\n        console.error(\"initMouseInputDetector(): Aborting initialization - targetEl undefined or not found!\");\n        return;\n    }\n    targetEl.addEventListener(\"mousedown\", () => targetEl.classList.add(\"using-mouse\"));\n    targetEl.addEventListener(\"keydown\", () => targetEl.classList.remove(\"using-mouse\"));\n}\nexports[\"default\"] = initMouseInputDetector;\n\n\n//# sourceURL=webpack://viktor-web/./helpers/js/mouse-input-detector.ts?");

/***/ }),

/***/ "./helpers/js/set-timeout-promise.ts":
/*!*******************************************!*\
  !*** ./helpers/js/set-timeout-promise.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction timeout(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nexports[\"default\"] = timeout;\n\n\n//# sourceURL=webpack://viktor-web/./helpers/js/set-timeout-promise.ts?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst html_dev_label_1 = __importDefault(__webpack_require__(/*! @codebundlesbyvik/html-dev-label */ \"./node_modules/@codebundlesbyvik/html-dev-label/index.js\"));\nconst mouse_input_detector_1 = __importDefault(__webpack_require__(/*! ./helpers/js/mouse-input-detector */ \"./helpers/js/mouse-input-detector.ts\"));\nconst typeit_1 = __importDefault(__webpack_require__(/*! ./components/about-me/typeit */ \"./components/about-me/typeit.ts\"));\nconst form_controller_1 = __importDefault(__webpack_require__(/*! ./components/form/form-controller */ \"./components/form/form-controller.js\"));\n__webpack_require__(/*! ./sass/style.scss */ \"./sass/style.scss\");\ndocument.documentElement.classList.replace(\"js-disabled\", \"has-js\");\n(0, mouse_input_detector_1.default)(document.body);\n(0, html_dev_label_1.default)();\n(0, typeit_1.default)(document.querySelector(\".viktor-about--typeit > span\"));\n(0, form_controller_1.default)(document.querySelector(\".form--contact\"));\n\n\n//# sourceURL=webpack://viktor-web/./index.ts?");

/***/ }),

/***/ "./node_modules/typeit/dist/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/typeit/dist/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TypeIt)\n/* harmony export */ });\n// TypeIt by Alex MacArthur - https://typeitjs.com\nconst isArray = (thing) => Array.isArray(thing);\nconst asArray = (value) => {\n  return isArray(value) ? value : [value];\n};\nlet Queue = function(initialItems) {\n  let add = function(steps) {\n    asArray(steps).forEach((step) => {\n      return _q.set(Symbol(step.char?.innerText), buildQueueItem({ ...step }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter((value) => value.typeable);\n  let set = function(index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = (queueItem) => {\n    queueItem.shouldPauseCursor = function() {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function() {\n    _q.forEach((item) => delete item.done);\n  };\n  let wipe = function() {\n    _q = /* @__PURE__ */ new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = (key) => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter((i) => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */ new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    reset,\n    destroy,\n    done,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst toArray = (val) => Array.from(val);\nconst createTextNode = (content) => document.createTextNode(content);\nlet expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map((n) => {\n        return { opacity: n };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      if (cursor && shouldIncludeCursor) {\n        if (node.classList?.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return node.classList?.contains(CURSOR_CLASS) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst createElement = (el) => document.createElement(el);\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(\n    Math.random() * (value + range2 - (value - range2)) + (value - range2)\n  );\n};\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\nconst destroyTimeouts = (timeouts) => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = (el) => \"value\" in el;\nlet getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(\n    (c) => !(c.childNodes.length > 0)\n  );\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver(\n    (entries, observer2) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          func();\n          observer2.unobserve(element);\n        }\n      });\n    },\n    { threshold: 1 }\n  );\n  observer.observe(element);\n};\nlet handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nconst isNumber = (value) => Number.isInteger(value);\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = (node) => /body/i.test(node?.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : character.originalParent || originalTarget;\n  target.insertBefore(\n    character,\n    select(\".\" + CURSOR_CLASS, target) || null\n  );\n};\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(\n    Math.max(cursorPosition + steps, 0),\n    printedCharacters.length\n  );\n};\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nconst removeNode = (node, rootElement) => {\n  if (!node)\n    return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? node : nodeParent;\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = nodeToInsertBefore?.parentNode || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nlet wait = (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce(\n    (accumulator, [item, value]) => {\n      return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n    },\n    \"\"\n  );\n  appendStyleBlock(\n    `${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`,\n    id\n  );\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({ char }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nlet beforePaint = (cb) => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = (element) => {\n  return element?.getAnimations().find((animation) => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions)\n    return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = (queueItem) => queueItem.func?.call(null);\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait: wait2,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nlet processCursorOptions = (cursorOptions) => {\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let { frames: defaultFrames, options: defaultOptions } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = cursorOptions.animation?.frames || defaultFrames;\n    newOptions.animation.options = merge(\n      defaultOptions,\n      cursorOptions.animation?.options || {}\n    );\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst TypeIt = function(element, options = {}) {\n  let _wait = async (callback, delay, silent = false) => {\n    if (_statuses.frozen) {\n      await new Promise((resolve) => {\n        this.unfreeze = () => {\n          _statuses.frozen = false;\n          resolve();\n        };\n      });\n    }\n    silent || await _opts.beforeStep(this);\n    await wait(callback, delay, _timeouts);\n    silent || await _opts.afterStep(this);\n  };\n  let _fireItemWithContext = (index, queueItems) => {\n    return fireItem({\n      index,\n      queueItems,\n      wait: _wait,\n      cursor: _cursor,\n      cursorOptions: _opts.cursor\n    });\n  };\n  let _removeNode = (node) => removeNode(node, _element);\n  let _elementIsInput = () => isInput(_element);\n  let _getPace = (index = 0) => calculatePace(_opts)[index];\n  let _getAllChars = () => getAllChars(_element);\n  let _maybeAppendPause = (opts = {}) => {\n    let delay = opts.delay;\n    delay && _queue.add({ delay });\n  };\n  let _queueAndReturn = (steps, opts) => {\n    _queue.add(steps);\n    _maybeAppendPause(opts);\n    return this;\n  };\n  let _getDerivedCursorPosition = () => _predictedCursorPosition ?? _cursorPosition;\n  let _generateTemporaryOptionQueueItems = (newOptions = {}) => {\n    return [\n      { func: () => _options(newOptions) },\n      { func: () => _options(_opts) }\n    ];\n  };\n  let _addSplitPause = (items) => {\n    let delay = _opts.nextStringDelay;\n    _queue.add([{ delay: delay[0] }, ...items, { delay: delay[1] }]);\n  };\n  let _setUpCursor = () => {\n    if (_elementIsInput()) {\n      return;\n    }\n    let cursor = createElement(\"span\");\n    cursor.className = CURSOR_CLASS;\n    if (!_shouldRenderCursor) {\n      cursor.style.visibility = \"hidden\";\n      return cursor;\n    }\n    cursor.innerHTML = getParsedBody(_opts.cursorChar).innerHTML;\n    return cursor;\n  };\n  let _attachCursor = async () => {\n    !_elementIsInput() && _cursor && _element.appendChild(_cursor);\n    if (_shouldRenderCursor) {\n      setCursorStyles(_id, _element);\n      _cursor.dataset.tiAnimationId = _id;\n      let { animation } = _opts.cursor;\n      let { frames, options: options2 } = animation;\n      setCursorAnimation({\n        frames,\n        cursor: _cursor,\n        options: {\n          duration: _opts.cursorSpeed,\n          ...options2\n        }\n      });\n    }\n  };\n  let _generateQueue = () => {\n    let strings = _opts.strings.filter((string) => !!string);\n    strings.forEach((string, index) => {\n      this.type(string);\n      if (index + 1 === strings.length) {\n        return;\n      }\n      let splitItems = _opts.breakLines ? [{ func: () => _type(createElement(\"BR\")), typeable: true }] : duplicate(\n        {\n          func: _delete,\n          delay: _getPace(1)\n        },\n        _queue.getTypeable().length\n      );\n      _addSplitPause(splitItems);\n    });\n  };\n  let _prepLoop = async (delay) => {\n    let derivedCursorPosition = _getDerivedCursorPosition();\n    derivedCursorPosition && await _move({ value: derivedCursorPosition });\n    let queueItems = _getAllChars().map((c) => {\n      return [\n        Symbol(),\n        {\n          func: _delete,\n          delay: _getPace(1),\n          deletable: true,\n          shouldPauseCursor: () => true\n        }\n      ];\n    });\n    for (let index = 0; index < queueItems.length; index++) {\n      await _fireItemWithContext(index, queueItems);\n    }\n    _queue.reset();\n    _queue.set(0, { delay });\n  };\n  let _maybePrependHardcodedStrings = (strings) => {\n    let existingMarkup = _element.innerHTML;\n    if (!existingMarkup) {\n      return strings;\n    }\n    _element.innerHTML = \"\";\n    if (_opts.startDelete) {\n      _element.innerHTML = existingMarkup;\n      expandTextNodes(_element);\n      _addSplitPause(\n        duplicate(\n          {\n            func: _delete,\n            delay: _getPace(1),\n            deletable: true\n          },\n          _getAllChars().length\n        )\n      );\n      return strings;\n    }\n    let hardCodedStrings = existingMarkup.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n    return hardCodedStrings.concat(strings);\n  };\n  let _fire = async (remember = true) => {\n    _statuses.started = true;\n    let cleanUp = (qKey) => {\n      _queue.done(qKey, !remember);\n    };\n    try {\n      let queueItems = [..._queue.getQueue()];\n      for (let index = 0; index < queueItems.length; index++) {\n        let [queueKey, queueItem] = queueItems[index];\n        if (queueItem.done)\n          continue;\n        if (!queueItem.deletable || queueItem.deletable && _getAllChars().length) {\n          let newIndex = await _fireItemWithContext(index, queueItems);\n          Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach((i) => {\n            let [key] = queueItems[i];\n            cleanUp(key);\n          });\n          index = newIndex;\n        }\n        cleanUp(queueKey);\n      }\n      if (!remember) {\n        return this;\n      }\n      _statuses.completed = true;\n      await _opts.afterComplete(this);\n      if (!_opts.loop) {\n        throw \"\";\n      }\n      let delay = _opts.loopDelay;\n      _wait(async () => {\n        await _prepLoop(delay[0]);\n        _fire();\n      }, delay[1]);\n    } catch (e) {\n    }\n    return this;\n  };\n  let _move = async (step) => {\n    _cursorPosition = updateCursorPosition(\n      step,\n      _cursorPosition,\n      _getAllChars()\n    );\n    repositionCursor(_element, _getAllChars(), _cursorPosition);\n  };\n  let _type = (char) => insertIntoElement(_element, char);\n  let _options = async (opts) => _opts = merge(_opts, opts);\n  let _empty = async () => {\n    if (_elementIsInput()) {\n      _element.value = \"\";\n      return;\n    }\n    _getAllChars().forEach(_removeNode);\n    return;\n  };\n  let _delete = () => {\n    let allChars = _getAllChars();\n    if (!allChars.length)\n      return;\n    if (_elementIsInput()) {\n      _element.value = _element.value.slice(0, -1);\n    } else {\n      _removeNode(allChars[_cursorPosition]);\n    }\n  };\n  this.break = function(actionOpts) {\n    return _queueAndReturn(\n      {\n        func: () => _type(createElement(\"BR\")),\n        typeable: true\n      },\n      actionOpts\n    );\n  };\n  this.delete = function(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    let typeableQueueItems = _queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: _getDerivedCursorPosition(),\n        to\n      });\n    })();\n    return _queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: _delete,\n            delay: instant ? 0 : _getPace(1),\n            deletable: true\n          },\n          rounds\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  };\n  this.empty = function(actionOpts = {}) {\n    return _queueAndReturn({ func: _empty }, actionOpts);\n  };\n  this.exec = function(func, actionOpts = {}) {\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    return _queueAndReturn(\n      [bookEndQueueItems[0], { func: () => func(this) }, bookEndQueueItems[1]],\n      actionOpts\n    );\n  };\n  this.move = function(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let { instant, to } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: _queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: _getDerivedCursorPosition()\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    _predictedCursorPosition = _getDerivedCursorPosition() + numberOfSteps;\n    return _queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: () => _move(directionalStep),\n            delay: instant ? 0 : _getPace(),\n            cursorable: true\n          },\n          Math.abs(numberOfSteps)\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  };\n  this.options = function(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    _options(opts);\n    return _queueAndReturn({}, actionOpts);\n  };\n  this.pause = function(milliseconds, actionOpts = {}) {\n    return _queueAndReturn(\n      { delay: handleFunctionalArg(milliseconds) },\n      actionOpts\n    );\n  };\n  this.type = function(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let { instant } = actionOpts;\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let chars = maybeChunkStringAsHtml(string, _opts.html);\n    let charsAsQueueItems = chars.map((char) => {\n      return {\n        func: () => _type(char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : _getPace(),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      { func: async () => await _opts.beforeString(string, this) },\n      ...charsAsQueueItems,\n      { func: async () => await _opts.afterString(string, this) },\n      bookEndQueueItems[1]\n    ];\n    return _queueAndReturn(itemsToQueue, actionOpts);\n  };\n  this.is = function(key) {\n    return _statuses[key];\n  };\n  this.destroy = function(shouldRemoveCursor = true) {\n    _timeouts = destroyTimeouts(_timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && _cursor && _removeNode(_cursor);\n    _statuses.destroyed = true;\n  };\n  this.freeze = function() {\n    _statuses.frozen = true;\n  };\n  this.unfreeze = () => {\n  };\n  this.reset = function(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      _queue.wipe();\n      rebuild(this);\n    } else {\n      _queue.reset();\n    }\n    _cursorPosition = 0;\n    for (let property in _statuses) {\n      _statuses[property] = false;\n    }\n    _element[_elementIsInput() ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  };\n  this.go = function() {\n    if (_statuses.started) {\n      return this;\n    }\n    _attachCursor();\n    if (!_opts.waitUntilVisible) {\n      _fire();\n      return this;\n    }\n    fireWhenVisible(_element, _fire.bind(this));\n    return this;\n  };\n  this.flush = function(cb = () => {\n  }) {\n    _attachCursor();\n    _fire(false).then(cb);\n    return this;\n  };\n  this.getQueue = () => _queue;\n  this.getOptions = () => _opts;\n  this.updateOptions = (options2) => _options(options2);\n  this.getElement = () => _element;\n  let _element = selectorToElement(element);\n  let _timeouts = [];\n  let _cursorPosition = 0;\n  let _predictedCursorPosition = null;\n  let _statuses = merge({}, DEFAULT_STATUSES);\n  options.cursor = processCursorOptions(\n    options.cursor ?? DEFAULT_OPTIONS.cursor\n  );\n  let _opts = merge(DEFAULT_OPTIONS, options);\n  _opts = merge(_opts, {\n    html: !_elementIsInput() && _opts.html,\n    nextStringDelay: calculateDelay(_opts.nextStringDelay),\n    loopDelay: calculateDelay(_opts.loopDelay)\n  });\n  let _id = generateHash();\n  let _queue = Queue([{ delay: _opts.startDelay }]);\n  _element.dataset.typeitId = _id;\n  appendStyleBlock(PLACEHOLDER_CSS);\n  let _shouldRenderCursor = !!_opts.cursor && !_elementIsInput();\n  let _cursor = _setUpCursor();\n  _opts.strings = _maybePrependHardcodedStrings(asArray(_opts.strings));\n  if (_opts.strings.length) {\n    _generateQueue();\n  }\n};\n\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/typeit/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/@codebundlesbyvik/css-operations/getPropValue.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@codebundlesbyvik/css-operations/getPropValue.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getPropValue)\n/* harmony export */ });\nfunction getPropValue(el, prop) {\r\n    const elStyles = window.getComputedStyle(el);\r\n    const propValue = elStyles.getPropertyValue(prop)\r\n\r\n    return propValue === \"\" ? null : propValue;\r\n}\r\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/@codebundlesbyvik/css-operations/getPropValue.js?");

/***/ }),

/***/ "./node_modules/@codebundlesbyvik/css-operations/getUnit.js":
/*!******************************************************************!*\
  !*** ./node_modules/@codebundlesbyvik/css-operations/getUnit.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getUnit)\n/* harmony export */ });\nfunction getUnit(value) {\r\n    let length = value.length;\r\n\r\n    if (!value || !length) {\r\n        return null;\r\n    }\r\n\r\n    let i = length;\r\n\r\n    while (i--) {\r\n        if (!isNaN(value[i])) {\r\n            return value.slice(i + 1, length) || null;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/@codebundlesbyvik/css-operations/getUnit.js?");

/***/ }),

/***/ "./node_modules/@codebundlesbyvik/css-operations/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@codebundlesbyvik/css-operations/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPropValue: () => (/* reexport safe */ _getPropValue_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   getUnit: () => (/* reexport safe */ _getUnit_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   motionAllowed: () => (/* reexport safe */ _mediaMotion_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   timeToMs: () => (/* reexport safe */ _timeToMs_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _getPropValue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPropValue.js */ \"./node_modules/@codebundlesbyvik/css-operations/getPropValue.js\");\n/* harmony import */ var _getUnit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getUnit.js */ \"./node_modules/@codebundlesbyvik/css-operations/getUnit.js\");\n/* harmony import */ var _mediaMotion_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mediaMotion.js */ \"./node_modules/@codebundlesbyvik/css-operations/mediaMotion.js\");\n/* harmony import */ var _timeToMs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./timeToMs.js */ \"./node_modules/@codebundlesbyvik/css-operations/timeToMs.js\");\n\n\n\n\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/@codebundlesbyvik/css-operations/index.js?");

/***/ }),

/***/ "./node_modules/@codebundlesbyvik/css-operations/mediaMotion.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@codebundlesbyvik/css-operations/mediaMotion.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ motionAllowed)\n/* harmony export */ });\nfunction motionAllowed() {\r\n    return !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\r\n}\r\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/@codebundlesbyvik/css-operations/mediaMotion.js?");

/***/ }),

/***/ "./node_modules/@codebundlesbyvik/css-operations/timeToMs.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@codebundlesbyvik/css-operations/timeToMs.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ timeToMs)\n/* harmony export */ });\n/* harmony import */ var _getUnit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getUnit.js */ \"./node_modules/@codebundlesbyvik/css-operations/getUnit.js\");\n\r\n\r\nfunction timeToMs(time) {\r\n    const number = parseFloat(time);\r\n\r\n    switch ((0,_getUnit_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(time)) {\r\n        case null:\r\n        case \"ms\":\r\n            return number;\r\n\r\n        case \"s\":\r\n            return number * 1000;\r\n\r\n        case \"m\":\r\n            return number * 60000;\r\n\r\n        case \"h\":\r\n            return number * 3600000;\r\n\r\n        case \"d\":\r\n            return number * 86400000;\r\n\r\n        case \"w\":\r\n            return number * 604800000;\r\n\r\n        case \"y\":\r\n            return number * 31536000000;\r\n\r\n        default:\r\n            return null;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://viktor-web/./node_modules/@codebundlesbyvik/css-operations/timeToMs.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ })()
;