{"version":3,"file":"bundle-main.js","mappings":"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","sources":["webpack://viktor-web/./node_modules/typeit/dist/index.es.js","webpack://viktor-web/./index.js","webpack://viktor-web/./components/about-me/typeit.js"],"sourcesContent":["// TypeIt by Alex MacArthur - https://typeitjs.com\nconst isArray = (thing) => Array.isArray(thing);\nconst asArray = (value) => {\n  return isArray(value) ? value : [value];\n};\nlet Queue = function(initialItems) {\n  let add = function(steps) {\n    asArray(steps).forEach((step) => {\n      return _q.set(Symbol(step.char?.innerText), buildQueueItem({ ...step }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter((value) => value.typeable);\n  let set = function(index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = (queueItem) => {\n    queueItem.shouldPauseCursor = function() {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function() {\n    _q.forEach((item) => delete item.done);\n  };\n  let wipe = function() {\n    _q = /* @__PURE__ */ new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = (key) => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter((i) => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */ new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    reset,\n    destroy,\n    done,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst toArray = (val) => Array.from(val);\nconst createTextNode = (content) => document.createTextNode(content);\nlet expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map((n) => {\n        return { opacity: n };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      if (cursor && shouldIncludeCursor) {\n        if (node.classList?.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return node.classList?.contains(CURSOR_CLASS) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst createElement = (el) => document.createElement(el);\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(Math.random() * (value + range2 - (value - range2)) + (value - range2));\n};\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\nconst destroyTimeouts = (timeouts) => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = (el) => \"value\" in el;\nlet getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter((c) => !(c.childNodes.length > 0));\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver((entries, observer2) => {\n    entries.forEach((entry) => {\n      if (entry.isIntersecting) {\n        func();\n        observer2.unobserve(element);\n      }\n    });\n  }, { threshold: 1 });\n  observer.observe(element);\n};\nlet handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nconst isNumber = (value) => Number.isInteger(value);\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = (node) => /body/i.test(node?.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : character.originalParent || originalTarget;\n  target.insertBefore(character, select(\".\" + CURSOR_CLASS, target) || null);\n};\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(Math.max(cursorPosition + steps, 0), printedCharacters.length);\n};\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nconst removeNode = (node, rootElement) => {\n  if (!node)\n    return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? node : nodeParent;\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = nodeToInsertBefore?.parentNode || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nlet wait = (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce((accumulator, [item, value]) => {\n    return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n  }, \"\");\n  appendStyleBlock(`${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`, id);\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({ char }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nlet beforePaint = (cb) => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = (element) => {\n  return element?.getAnimations().find((animation) => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions)\n    return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = (queueItem) => queueItem.func?.call(null);\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait: wait2,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nlet processCursorOptions = (cursorOptions) => {\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let { frames: defaultFrames, options: defaultOptions } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = cursorOptions.animation?.frames || defaultFrames;\n    newOptions.animation.options = merge(defaultOptions, cursorOptions.animation?.options || {});\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst TypeIt = function(element, options = {}) {\n  let _wait = async (callback, delay, silent = false) => {\n    if (_statuses.frozen) {\n      await new Promise((resolve) => {\n        this.unfreeze = () => {\n          _statuses.frozen = false;\n          resolve();\n        };\n      });\n    }\n    silent || await _opts.beforeStep(this);\n    await wait(callback, delay, _timeouts);\n    silent || await _opts.afterStep(this);\n  };\n  let _fireItemWithContext = (index, queueItems) => {\n    return fireItem({\n      index,\n      queueItems,\n      wait: _wait,\n      cursor: _cursor,\n      cursorOptions: _opts.cursor\n    });\n  };\n  let _removeNode = (node) => removeNode(node, _element);\n  let _elementIsInput = () => isInput(_element);\n  let _getPace = (index = 0) => calculatePace(_opts)[index];\n  let _getAllChars = () => getAllChars(_element);\n  let _maybeAppendPause = (opts = {}) => {\n    let delay = opts.delay;\n    delay && _queue.add({ delay });\n  };\n  let _queueAndReturn = (steps, opts) => {\n    _queue.add(steps);\n    _maybeAppendPause(opts);\n    return this;\n  };\n  let _getDerivedCursorPosition = () => _predictedCursorPosition ?? _cursorPosition;\n  let _generateTemporaryOptionQueueItems = (newOptions = {}) => {\n    return [\n      { func: () => _options(newOptions) },\n      { func: () => _options(_opts) }\n    ];\n  };\n  let _addSplitPause = (items) => {\n    let delay = _opts.nextStringDelay;\n    _queue.add([{ delay: delay[0] }, ...items, { delay: delay[1] }]);\n  };\n  let _setUpCursor = () => {\n    if (_elementIsInput()) {\n      return;\n    }\n    let cursor = createElement(\"span\");\n    cursor.className = CURSOR_CLASS;\n    if (!_shouldRenderCursor) {\n      cursor.style.visibility = \"hidden\";\n      return cursor;\n    }\n    cursor.innerHTML = getParsedBody(_opts.cursorChar).innerHTML;\n    return cursor;\n  };\n  let _attachCursor = async () => {\n    !_elementIsInput() && _cursor && _element.appendChild(_cursor);\n    if (_shouldRenderCursor) {\n      setCursorStyles(_id, _element);\n      _cursor.dataset.tiAnimationId = _id;\n      let { animation } = _opts.cursor;\n      let { frames, options: options2 } = animation;\n      setCursorAnimation({\n        frames,\n        cursor: _cursor,\n        options: {\n          duration: _opts.cursorSpeed,\n          ...options2\n        }\n      });\n    }\n  };\n  let _generateQueue = () => {\n    let strings = _opts.strings.filter((string) => !!string);\n    strings.forEach((string, index) => {\n      this.type(string);\n      if (index + 1 === strings.length) {\n        return;\n      }\n      let splitItems = _opts.breakLines ? [{ func: () => _type(createElement(\"BR\")), typeable: true }] : duplicate({\n        func: _delete,\n        delay: _getPace(1)\n      }, _queue.getTypeable().length);\n      _addSplitPause(splitItems);\n    });\n  };\n  let _prepLoop = async (delay) => {\n    let derivedCursorPosition = _getDerivedCursorPosition();\n    derivedCursorPosition && await _move({ value: derivedCursorPosition });\n    let queueItems = _getAllChars().map((c) => {\n      return [\n        Symbol(),\n        {\n          func: _delete,\n          delay: _getPace(1),\n          deletable: true,\n          shouldPauseCursor: () => true\n        }\n      ];\n    });\n    for (let index = 0; index < queueItems.length; index++) {\n      await _fireItemWithContext(index, queueItems);\n    }\n    _queue.reset();\n    _queue.set(0, { delay });\n  };\n  let _maybePrependHardcodedStrings = (strings) => {\n    let existingMarkup = _element.innerHTML;\n    if (!existingMarkup) {\n      return strings;\n    }\n    _element.innerHTML = \"\";\n    if (_opts.startDelete) {\n      _element.innerHTML = existingMarkup;\n      expandTextNodes(_element);\n      _addSplitPause(duplicate({\n        func: _delete,\n        delay: _getPace(1),\n        deletable: true\n      }, _getAllChars().length));\n      return strings;\n    }\n    let hardCodedStrings = existingMarkup.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n    return hardCodedStrings.concat(strings);\n  };\n  let _fire = async (remember = true) => {\n    _statuses.started = true;\n    let cleanUp = (qKey) => {\n      _queue.done(qKey, !remember);\n    };\n    try {\n      let queueItems = [..._queue.getQueue()];\n      for (let index = 0; index < queueItems.length; index++) {\n        let [queueKey, queueItem] = queueItems[index];\n        if (queueItem.done)\n          continue;\n        if (!queueItem.deletable || queueItem.deletable && _getAllChars().length) {\n          let newIndex = await _fireItemWithContext(index, queueItems);\n          Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach((i) => {\n            let [key] = queueItems[i];\n            cleanUp(key);\n          });\n          index = newIndex;\n        }\n        cleanUp(queueKey);\n      }\n      if (!remember) {\n        return this;\n      }\n      _statuses.completed = true;\n      await _opts.afterComplete(this);\n      if (!_opts.loop) {\n        throw \"\";\n      }\n      let delay = _opts.loopDelay;\n      _wait(async () => {\n        await _prepLoop(delay[0]);\n        _fire();\n      }, delay[1]);\n    } catch (e) {\n    }\n    return this;\n  };\n  let _move = async (step) => {\n    _cursorPosition = updateCursorPosition(step, _cursorPosition, _getAllChars());\n    repositionCursor(_element, _getAllChars(), _cursorPosition);\n  };\n  let _type = (char) => insertIntoElement(_element, char);\n  let _options = async (opts) => _opts = merge(_opts, opts);\n  let _empty = async () => {\n    if (_elementIsInput()) {\n      _element.value = \"\";\n      return;\n    }\n    _getAllChars().forEach(_removeNode);\n    return;\n  };\n  let _delete = () => {\n    let allChars = _getAllChars();\n    if (!allChars.length)\n      return;\n    if (_elementIsInput()) {\n      _element.value = _element.value.slice(0, -1);\n    } else {\n      _removeNode(allChars[_cursorPosition]);\n    }\n  };\n  this.break = function(actionOpts) {\n    return _queueAndReturn({\n      func: () => _type(createElement(\"BR\")),\n      typeable: true\n    }, actionOpts);\n  };\n  this.delete = function(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    let typeableQueueItems = _queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: _getDerivedCursorPosition(),\n        to\n      });\n    })();\n    return _queueAndReturn([\n      bookEndQueueItems[0],\n      ...duplicate({\n        func: _delete,\n        delay: instant ? 0 : _getPace(1),\n        deletable: true\n      }, rounds),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  };\n  this.empty = function(actionOpts = {}) {\n    return _queueAndReturn({ func: _empty }, actionOpts);\n  };\n  this.exec = function(func, actionOpts = {}) {\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    return _queueAndReturn([bookEndQueueItems[0], { func: () => func(this) }, bookEndQueueItems[1]], actionOpts);\n  };\n  this.move = function(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let { instant, to } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: _queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: _getDerivedCursorPosition()\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    _predictedCursorPosition = _getDerivedCursorPosition() + numberOfSteps;\n    return _queueAndReturn([\n      bookEndQueueItems[0],\n      ...duplicate({\n        func: () => _move(directionalStep),\n        delay: instant ? 0 : _getPace(),\n        cursorable: true\n      }, Math.abs(numberOfSteps)),\n      bookEndQueueItems[1]\n    ], actionOpts);\n  };\n  this.options = function(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    _options(opts);\n    return _queueAndReturn({}, actionOpts);\n  };\n  this.pause = function(milliseconds, actionOpts = {}) {\n    return _queueAndReturn({ delay: handleFunctionalArg(milliseconds) }, actionOpts);\n  };\n  this.type = function(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let { instant } = actionOpts;\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let chars = maybeChunkStringAsHtml(string, _opts.html);\n    let charsAsQueueItems = chars.map((char) => {\n      return {\n        func: () => _type(char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : _getPace(),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      { func: async () => await _opts.beforeString(string, this) },\n      ...charsAsQueueItems,\n      { func: async () => await _opts.afterString(string, this) },\n      bookEndQueueItems[1]\n    ];\n    return _queueAndReturn(itemsToQueue, actionOpts);\n  };\n  this.is = function(key) {\n    return _statuses[key];\n  };\n  this.destroy = function(shouldRemoveCursor = true) {\n    _timeouts = destroyTimeouts(_timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && _cursor && _removeNode(_cursor);\n    _statuses.destroyed = true;\n  };\n  this.freeze = function() {\n    _statuses.frozen = true;\n  };\n  this.unfreeze = () => {\n  };\n  this.reset = function(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      _queue.wipe();\n      rebuild(this);\n    } else {\n      _queue.reset();\n    }\n    _cursorPosition = 0;\n    for (let property in _statuses) {\n      _statuses[property] = false;\n    }\n    _element[_elementIsInput() ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  };\n  this.go = function() {\n    if (_statuses.started) {\n      return this;\n    }\n    _attachCursor();\n    if (!_opts.waitUntilVisible) {\n      _fire();\n      return this;\n    }\n    fireWhenVisible(_element, _fire.bind(this));\n    return this;\n  };\n  this.flush = function(cb = () => {\n  }) {\n    _attachCursor();\n    _fire(false).then(cb);\n    return this;\n  };\n  this.getQueue = () => _queue;\n  this.getOptions = () => _opts;\n  this.updateOptions = (options2) => _options(options2);\n  this.getElement = () => _element;\n  let _element = selectorToElement(element);\n  let _timeouts = [];\n  let _cursorPosition = 0;\n  let _predictedCursorPosition = null;\n  let _statuses = merge({}, DEFAULT_STATUSES);\n  options.cursor = processCursorOptions(options.cursor ?? DEFAULT_OPTIONS.cursor);\n  let _opts = merge(DEFAULT_OPTIONS, options);\n  _opts = merge(_opts, {\n    html: !_elementIsInput() && _opts.html,\n    nextStringDelay: calculateDelay(_opts.nextStringDelay),\n    loopDelay: calculateDelay(_opts.loopDelay)\n  });\n  let _id = generateHash();\n  let _queue = Queue([{ delay: _opts.startDelay }]);\n  _element.dataset.typeitId = _id;\n  appendStyleBlock(PLACEHOLDER_CSS);\n  let _shouldRenderCursor = !!_opts.cursor && !_elementIsInput();\n  let _cursor = _setUpCursor();\n  _opts.strings = _maybePrependHardcodedStrings(asArray(_opts.strings));\n  if (_opts.strings.length) {\n    _generateQueue();\n  }\n};\nexport {\n  TypeIt as default\n};\n","import htmlDevLabel from \"@codebundlesbyvik/html-dev-label\";\nimport typeItAboutMe from \"./components/about-me/typeit\";\nimport \"./sass/style.scss\";\n\nreplaceBodyJsClass(document.documentElement);\n\ninitMouseInputDetector(document.body);\n\nhtmlDevLabel();\n\ntypeItAboutMe(document.querySelector(\".viktor-about--typeit > span\"));\n\nfunction replaceBodyJsClass(targetEl) {\n    targetEl.classList.replace(\"no-js\", \"js\");\n}\n\nfunction initMouseInputDetector(targetEl) {\n    console.log(\"In initMouseInputDetector().\");\n\n    targetEl.addEventListener(\"mousedown\", function() {\n        targetEl.classList.add(\"using-mouse\");\n    });\n\n    targetEl.addEventListener(\"keydown\", function() {\n        targetEl.classList.remove(\"using-mouse\");\n    });\n}\n","import TypeIt from \"typeit\";\n\nexport default function typeItAboutMe(targetEl) {\n    new TypeIt(targetEl, {\n        speed: 75,\n        deleteSpeed: 40,\n        loop: true\n    })\n        //\n        .type(\"Photographer\", {delay: 1800})\n        .delete(null, {delay: 1000})\n        //\n        .type(\"Web devlo\", {delay: 500})\n        .move(-2, {speed: 150, delay: 350})\n        .type(\"e\", {delay: 500})\n        .move(2, {speed: 100, delay: 400})\n        .type(\"per\", {delay: 1850})\n        .delete(null, {delay: 1000})\n        //\n        .type(\"Moti\", {delay: 400})\n        .delete(2, {speed: 120, delay: 350})\n        .type(\"toring enthusiast\", {delay: 2000})\n        .delete(null, {delay: 900})\n        //\n        .type(\"Human\", {delay: 1450})\n        .delete(null, {delay: 900})\n        //\n        .go();\n};\n"],"names":["isArray","thing","Array","asArray","value","toArray","val","from","createTextNode","content","document","expandTextNodes","element","childNodes","forEach","child","nodeValue","c","parentNode","insertBefore","remove","getParsedBody","doc","implementation","createHTMLDocument","body","innerHTML","CURSOR_CLASS","DEFAULT_STATUSES","started","completed","frozen","destroyed","DEFAULT_OPTIONS","breakLines","cursor","autoPause","autoPauseDelay","animation","frames","map","n","opacity","options","iterations","Infinity","easing","fill","cursorChar","cursorSpeed","deleteSpeed","html","lifeLike","loop","loopDelay","nextStringDelay","speed","startDelay","startDelete","strings","waitUntilVisible","beforeString","afterString","beforeStep","afterStep","afterComplete","walkElementNodes","shouldReverse","shouldIncludeCursor","nextNode","querySelector","walker","createTreeWalker","NodeFilter","SHOW_ALL","acceptNode","node","classList","contains","FILTER_ACCEPT","FILTER_REJECT","nodes","originalParent","push","reverse","maybeChunkStringAsHtml","str","asHtml","createElement","el","appendStyleBlock","styles","id","styleBlock","appendChild","head","calculateDelay","delayArg","randomInRange","range2","Math","abs","random","range","isInput","handleFunctionalArg","arg","isNumber","Number","isInteger","selector","all","merge","originalObj","newObj","Object","assign","cursorFontStyles","color","transform","duplicate","times","countStepsToSelector","queueItems","cursorPosition","to","isMovingToEnd","RegExp","test","selectorIndex","findIndex","char","parentElement","parentMatches","matches","firstChild","isSameNode","length","beforePaint","cb","Promise","resolve","requestAnimationFrame","async","getAnimationFromElement","getAnimations","find","dataset","tiAnimationId","setCursorAnimation","animate","pause","play","execute","queueItem","func","call","fireItem","index","wait","wait2","cursorOptions","instantQueue","tempIndex","futureItem","shouldBeGrouped","delay","shouldPauseCursor","q","effect","getComputedTiming","cancel","oldCurrentTime","currentTime","newAnimation","rebuildCursorAnimation","TypeIt","_wait","callback","silent","_statuses","this","unfreeze","_opts","timeouts","setTimeout","_timeouts","_fireItemWithContext","_cursor","_removeNode","rootElement","nodeParent","removeNode","_element","_elementIsInput","_getPace","calculatePace","_getAllChars","filter","getAllChars","_queueAndReturn","steps","opts","_queue","add","_maybeAppendPause","_getDerivedCursorPosition","_predictedCursorPosition","_cursorPosition","_generateTemporaryOptionQueueItems","newOptions","_options","_addSplitPause","items","_attachCursor","_shouldRenderCursor","cursorSelector","computedStyles","getComputedStyle","customProperties","entries","reduce","accumulator","item","setCursorStyles","_id","options2","duration","_generateQueue","string","type","splitItems","_type","typeable","_delete","getTypeable","_fire","remember","cleanUp","qKey","done","getQueue","queueKey","deletable","newIndex","x","y","i","key","derivedCursorPosition","_move","Symbol","reset","set","_prepLoop","e","step","printedCharacters","min","max","allChars","newCursorPosition","nodeToInsertBefore","repositionCursor","originalTarget","character","textContent","target","tagName","insertIntoElement","_empty","slice","break","actionOpts","delete","numCharacters","bookEndQueueItems","num","instant","typeableQueueItems","rounds","empty","exec","move","movementArg","numberOfSteps","directionalStep","cursorable","milliseconds","charsAsQueueItems","outerHTML","nodeType","Node","TEXT_NODE","itemsToQueue","is","destroy","shouldRemoveCursor","clearTimeout","freeze","rebuild","wipe","property","go","IntersectionObserver","observer2","entry","isIntersecting","unobserve","threshold","observe","fireWhenVisible","bind","flush","then","getOptions","updateOptions","getElement","defaultFrames","defaultOptions","processCursorOptions","toString","substring","initialItems","_q","innerText","buildQueueItem","Boolean","rawValues","values","Map","keys","shouldDestroy","get","getItems","Queue","typeitId","className","style","visibility","_setUpCursor","existingMarkup","replace","trim","split","concat","_maybePrependHardcodedStrings","documentElement","targetEl","addEventListener","initMouseInputDetector","typeItAboutMe"],"sourceRoot":""}