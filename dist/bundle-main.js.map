{"version":3,"file":"bundle-main.js","mappings":"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","sources":["webpack://viktor-web/./node_modules/typeit/dist/index.es.js","webpack://viktor-web/./index.js","webpack://viktor-web/./components/about-me/typeit.js"],"sourcesContent":["// TypeIt by Alex MacArthur - https://typeitjs.com\nconst isArray = (thing) => Array.isArray(thing);\nconst asArray = (value) => {\n  return isArray(value) ? value : [value];\n};\nlet Queue = function(initialItems) {\n  let add = function(steps) {\n    asArray(steps).forEach((step) => {\n      return _q.set(Symbol(step.char?.innerText), buildQueueItem({ ...step }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter((value) => value.typeable);\n  let set = function(index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = (queueItem) => {\n    queueItem.shouldPauseCursor = function() {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function() {\n    _q.forEach((item) => delete item.done);\n  };\n  let wipe = function() {\n    _q = /* @__PURE__ */ new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = (key) => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter((i) => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */ new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    reset,\n    destroy,\n    done,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst toArray = (val) => Array.from(val);\nconst createTextNode = (content) => document.createTextNode(content);\nlet expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map((n) => {\n        return { opacity: n };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      if (cursor && shouldIncludeCursor) {\n        if (node.classList?.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return node.classList?.contains(CURSOR_CLASS) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst createElement = (el) => document.createElement(el);\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(\n    Math.random() * (value + range2 - (value - range2)) + (value - range2)\n  );\n};\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\nconst destroyTimeouts = (timeouts) => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = (el) => \"value\" in el;\nlet getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(\n    (c) => !(c.childNodes.length > 0)\n  );\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver(\n    (entries, observer2) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          func();\n          observer2.unobserve(element);\n        }\n      });\n    },\n    { threshold: 1 }\n  );\n  observer.observe(element);\n};\nlet handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nconst isNumber = (value) => Number.isInteger(value);\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = (node) => /body/i.test(node?.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : character.originalParent || originalTarget;\n  target.insertBefore(\n    character,\n    select(\".\" + CURSOR_CLASS, target) || null\n  );\n};\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(\n    Math.max(cursorPosition + steps, 0),\n    printedCharacters.length\n  );\n};\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nconst removeNode = (node, rootElement) => {\n  if (!node)\n    return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? node : nodeParent;\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = nodeToInsertBefore?.parentNode || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nlet wait = (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce(\n    (accumulator, [item, value]) => {\n      return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n    },\n    \"\"\n  );\n  appendStyleBlock(\n    `${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`,\n    id\n  );\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({ char }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nlet beforePaint = (cb) => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = (element) => {\n  return element?.getAnimations().find((animation) => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions)\n    return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = (queueItem) => queueItem.func?.call(null);\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait: wait2,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nlet processCursorOptions = (cursorOptions) => {\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let { frames: defaultFrames, options: defaultOptions } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = cursorOptions.animation?.frames || defaultFrames;\n    newOptions.animation.options = merge(\n      defaultOptions,\n      cursorOptions.animation?.options || {}\n    );\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst TypeIt = function(element, options = {}) {\n  let _wait = async (callback, delay, silent = false) => {\n    if (_statuses.frozen) {\n      await new Promise((resolve) => {\n        this.unfreeze = () => {\n          _statuses.frozen = false;\n          resolve();\n        };\n      });\n    }\n    silent || await _opts.beforeStep(this);\n    await wait(callback, delay, _timeouts);\n    silent || await _opts.afterStep(this);\n  };\n  let _fireItemWithContext = (index, queueItems) => {\n    return fireItem({\n      index,\n      queueItems,\n      wait: _wait,\n      cursor: _cursor,\n      cursorOptions: _opts.cursor\n    });\n  };\n  let _removeNode = (node) => removeNode(node, _element);\n  let _elementIsInput = () => isInput(_element);\n  let _getPace = (index = 0) => calculatePace(_opts)[index];\n  let _getAllChars = () => getAllChars(_element);\n  let _maybeAppendPause = (opts = {}) => {\n    let delay = opts.delay;\n    delay && _queue.add({ delay });\n  };\n  let _queueAndReturn = (steps, opts) => {\n    _queue.add(steps);\n    _maybeAppendPause(opts);\n    return this;\n  };\n  let _getDerivedCursorPosition = () => _predictedCursorPosition ?? _cursorPosition;\n  let _generateTemporaryOptionQueueItems = (newOptions = {}) => {\n    return [\n      { func: () => _options(newOptions) },\n      { func: () => _options(_opts) }\n    ];\n  };\n  let _addSplitPause = (items) => {\n    let delay = _opts.nextStringDelay;\n    _queue.add([{ delay: delay[0] }, ...items, { delay: delay[1] }]);\n  };\n  let _setUpCursor = () => {\n    if (_elementIsInput()) {\n      return;\n    }\n    let cursor = createElement(\"span\");\n    cursor.className = CURSOR_CLASS;\n    if (!_shouldRenderCursor) {\n      cursor.style.visibility = \"hidden\";\n      return cursor;\n    }\n    cursor.innerHTML = getParsedBody(_opts.cursorChar).innerHTML;\n    return cursor;\n  };\n  let _attachCursor = async () => {\n    !_elementIsInput() && _cursor && _element.appendChild(_cursor);\n    if (_shouldRenderCursor) {\n      setCursorStyles(_id, _element);\n      _cursor.dataset.tiAnimationId = _id;\n      let { animation } = _opts.cursor;\n      let { frames, options: options2 } = animation;\n      setCursorAnimation({\n        frames,\n        cursor: _cursor,\n        options: {\n          duration: _opts.cursorSpeed,\n          ...options2\n        }\n      });\n    }\n  };\n  let _generateQueue = () => {\n    let strings = _opts.strings.filter((string) => !!string);\n    strings.forEach((string, index) => {\n      this.type(string);\n      if (index + 1 === strings.length) {\n        return;\n      }\n      let splitItems = _opts.breakLines ? [{ func: () => _type(createElement(\"BR\")), typeable: true }] : duplicate(\n        {\n          func: _delete,\n          delay: _getPace(1)\n        },\n        _queue.getTypeable().length\n      );\n      _addSplitPause(splitItems);\n    });\n  };\n  let _prepLoop = async (delay) => {\n    let derivedCursorPosition = _getDerivedCursorPosition();\n    derivedCursorPosition && await _move({ value: derivedCursorPosition });\n    let queueItems = _getAllChars().map((c) => {\n      return [\n        Symbol(),\n        {\n          func: _delete,\n          delay: _getPace(1),\n          deletable: true,\n          shouldPauseCursor: () => true\n        }\n      ];\n    });\n    for (let index = 0; index < queueItems.length; index++) {\n      await _fireItemWithContext(index, queueItems);\n    }\n    _queue.reset();\n    _queue.set(0, { delay });\n  };\n  let _maybePrependHardcodedStrings = (strings) => {\n    let existingMarkup = _element.innerHTML;\n    if (!existingMarkup) {\n      return strings;\n    }\n    _element.innerHTML = \"\";\n    if (_opts.startDelete) {\n      _element.innerHTML = existingMarkup;\n      expandTextNodes(_element);\n      _addSplitPause(\n        duplicate(\n          {\n            func: _delete,\n            delay: _getPace(1),\n            deletable: true\n          },\n          _getAllChars().length\n        )\n      );\n      return strings;\n    }\n    let hardCodedStrings = existingMarkup.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n    return hardCodedStrings.concat(strings);\n  };\n  let _fire = async (remember = true) => {\n    _statuses.started = true;\n    let cleanUp = (qKey) => {\n      _queue.done(qKey, !remember);\n    };\n    try {\n      let queueItems = [..._queue.getQueue()];\n      for (let index = 0; index < queueItems.length; index++) {\n        let [queueKey, queueItem] = queueItems[index];\n        if (queueItem.done)\n          continue;\n        if (!queueItem.deletable || queueItem.deletable && _getAllChars().length) {\n          let newIndex = await _fireItemWithContext(index, queueItems);\n          Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach((i) => {\n            let [key] = queueItems[i];\n            cleanUp(key);\n          });\n          index = newIndex;\n        }\n        cleanUp(queueKey);\n      }\n      if (!remember) {\n        return this;\n      }\n      _statuses.completed = true;\n      await _opts.afterComplete(this);\n      if (!_opts.loop) {\n        throw \"\";\n      }\n      let delay = _opts.loopDelay;\n      _wait(async () => {\n        await _prepLoop(delay[0]);\n        _fire();\n      }, delay[1]);\n    } catch (e) {\n    }\n    return this;\n  };\n  let _move = async (step) => {\n    _cursorPosition = updateCursorPosition(\n      step,\n      _cursorPosition,\n      _getAllChars()\n    );\n    repositionCursor(_element, _getAllChars(), _cursorPosition);\n  };\n  let _type = (char) => insertIntoElement(_element, char);\n  let _options = async (opts) => _opts = merge(_opts, opts);\n  let _empty = async () => {\n    if (_elementIsInput()) {\n      _element.value = \"\";\n      return;\n    }\n    _getAllChars().forEach(_removeNode);\n    return;\n  };\n  let _delete = () => {\n    let allChars = _getAllChars();\n    if (!allChars.length)\n      return;\n    if (_elementIsInput()) {\n      _element.value = _element.value.slice(0, -1);\n    } else {\n      _removeNode(allChars[_cursorPosition]);\n    }\n  };\n  this.break = function(actionOpts) {\n    return _queueAndReturn(\n      {\n        func: () => _type(createElement(\"BR\")),\n        typeable: true\n      },\n      actionOpts\n    );\n  };\n  this.delete = function(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    let typeableQueueItems = _queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: _getDerivedCursorPosition(),\n        to\n      });\n    })();\n    return _queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: _delete,\n            delay: instant ? 0 : _getPace(1),\n            deletable: true\n          },\n          rounds\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  };\n  this.empty = function(actionOpts = {}) {\n    return _queueAndReturn({ func: _empty }, actionOpts);\n  };\n  this.exec = function(func, actionOpts = {}) {\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    return _queueAndReturn(\n      [bookEndQueueItems[0], { func: () => func(this) }, bookEndQueueItems[1]],\n      actionOpts\n    );\n  };\n  this.move = function(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let { instant, to } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: _queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: _getDerivedCursorPosition()\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    _predictedCursorPosition = _getDerivedCursorPosition() + numberOfSteps;\n    return _queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: () => _move(directionalStep),\n            delay: instant ? 0 : _getPace(),\n            cursorable: true\n          },\n          Math.abs(numberOfSteps)\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  };\n  this.options = function(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    _options(opts);\n    return _queueAndReturn({}, actionOpts);\n  };\n  this.pause = function(milliseconds, actionOpts = {}) {\n    return _queueAndReturn(\n      { delay: handleFunctionalArg(milliseconds) },\n      actionOpts\n    );\n  };\n  this.type = function(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let { instant } = actionOpts;\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let chars = maybeChunkStringAsHtml(string, _opts.html);\n    let charsAsQueueItems = chars.map((char) => {\n      return {\n        func: () => _type(char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : _getPace(),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      { func: async () => await _opts.beforeString(string, this) },\n      ...charsAsQueueItems,\n      { func: async () => await _opts.afterString(string, this) },\n      bookEndQueueItems[1]\n    ];\n    return _queueAndReturn(itemsToQueue, actionOpts);\n  };\n  this.is = function(key) {\n    return _statuses[key];\n  };\n  this.destroy = function(shouldRemoveCursor = true) {\n    _timeouts = destroyTimeouts(_timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && _cursor && _removeNode(_cursor);\n    _statuses.destroyed = true;\n  };\n  this.freeze = function() {\n    _statuses.frozen = true;\n  };\n  this.unfreeze = () => {\n  };\n  this.reset = function(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      _queue.wipe();\n      rebuild(this);\n    } else {\n      _queue.reset();\n    }\n    _cursorPosition = 0;\n    for (let property in _statuses) {\n      _statuses[property] = false;\n    }\n    _element[_elementIsInput() ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  };\n  this.go = function() {\n    if (_statuses.started) {\n      return this;\n    }\n    _attachCursor();\n    if (!_opts.waitUntilVisible) {\n      _fire();\n      return this;\n    }\n    fireWhenVisible(_element, _fire.bind(this));\n    return this;\n  };\n  this.flush = function(cb = () => {\n  }) {\n    _attachCursor();\n    _fire(false).then(cb);\n    return this;\n  };\n  this.getQueue = () => _queue;\n  this.getOptions = () => _opts;\n  this.updateOptions = (options2) => _options(options2);\n  this.getElement = () => _element;\n  let _element = selectorToElement(element);\n  let _timeouts = [];\n  let _cursorPosition = 0;\n  let _predictedCursorPosition = null;\n  let _statuses = merge({}, DEFAULT_STATUSES);\n  options.cursor = processCursorOptions(\n    options.cursor ?? DEFAULT_OPTIONS.cursor\n  );\n  let _opts = merge(DEFAULT_OPTIONS, options);\n  _opts = merge(_opts, {\n    html: !_elementIsInput() && _opts.html,\n    nextStringDelay: calculateDelay(_opts.nextStringDelay),\n    loopDelay: calculateDelay(_opts.loopDelay)\n  });\n  let _id = generateHash();\n  let _queue = Queue([{ delay: _opts.startDelay }]);\n  _element.dataset.typeitId = _id;\n  appendStyleBlock(PLACEHOLDER_CSS);\n  let _shouldRenderCursor = !!_opts.cursor && !_elementIsInput();\n  let _cursor = _setUpCursor();\n  _opts.strings = _maybePrependHardcodedStrings(asArray(_opts.strings));\n  if (_opts.strings.length) {\n    _generateQueue();\n  }\n};\nexport {\n  TypeIt as default\n};\n","import htmlDevLabel from \"@codebundlesbyvik/html-dev-label\";\nimport typeItAboutMe from \"./components/about-me/typeit\";\nimport initContactForm from \"./components/form/form-controller\";\nimport \"./sass/style.scss\";\n\nreplaceJsClass(document.documentElement);\n\ninitMouseInputDetector(document.body);\n\nhtmlDevLabel();\n\ntypeItAboutMe(document.querySelector(\".viktor-about--typeit > span\"));\n\n// initContactForm(document.querySelector(\".form--contact\"));\n\nfunction replaceJsClass(targetEl) {\n    targetEl.classList.replace(\"no-js\", \"js\");\n}\n\nfunction initMouseInputDetector(targetEl) {\n    targetEl.addEventListener(\"mousedown\", () => targetEl.classList.add(\"using-mouse\"));\n    targetEl.addEventListener(\"keydown\", () => targetEl.classList.remove(\"using-mouse\"));\n}\n","import TypeIt from \"typeit\";\n\nexport default function typeItAboutMe(targetEl) {\n    return new TypeIt(targetEl, {\n        speed: 75,\n        deleteSpeed: 40,\n        loop: true\n    })\n        //\n        .type(\"Photographer\", {delay: 1800})\n        .delete(null, {delay: 1000})\n        //\n        .type(\"Web devlo\", {delay: 500})\n        .move(-2, {speed: 150, delay: 350})\n        .type(\"e\", {delay: 500})\n        .move(2, {speed: 100, delay: 400})\n        .type(\"per\", {delay: 1850})\n        .delete(null, {delay: 1000})\n        //\n        .type(\"Moti\", {delay: 400})\n        .delete(2, {speed: 120, delay: 350})\n        .type(\"toring enthusiast\", {delay: 2000})\n        .delete(null, {delay: 900})\n        //\n        .type(\"Human\", {delay: 1450})\n        .delete(null, {delay: 900})\n        //\n        .go();\n};\n"],"names":["isArray","thing","Array","asArray","value","toArray","val","from","createTextNode","content","document","expandTextNodes","element","childNodes","forEach","child","nodeValue","c","parentNode","insertBefore","remove","getParsedBody","doc","implementation","createHTMLDocument","body","innerHTML","DATA_ATTRIBUTE","CURSOR_CLASS","DEFAULT_STATUSES","started","completed","frozen","destroyed","DEFAULT_OPTIONS","breakLines","cursor","autoPause","autoPauseDelay","animation","frames","map","n","opacity","options","iterations","Infinity","easing","fill","cursorChar","cursorSpeed","deleteSpeed","html","lifeLike","loop","loopDelay","nextStringDelay","speed","startDelay","startDelete","strings","waitUntilVisible","beforeString","afterString","beforeStep","afterStep","afterComplete","PLACEHOLDER_CSS","walkElementNodes","shouldReverse","shouldIncludeCursor","nextNode","querySelector","walker","createTreeWalker","NodeFilter","SHOW_ALL","acceptNode","node","classList","contains","FILTER_ACCEPT","FILTER_REJECT","nodes","originalParent","push","reverse","maybeChunkStringAsHtml","str","asHtml","createElement","el","appendStyleBlock","styles","id","styleBlock","appendChild","head","calculateDelay","delayArg","randomInRange","range2","Math","abs","random","range","isInput","handleFunctionalArg","arg","isNumber","Number","isInteger","selector","all","merge","originalObj","newObj","Object","assign","cursorFontStyles","color","transform","duplicate","times","countStepsToSelector","queueItems","cursorPosition","to","isMovingToEnd","RegExp","test","selectorIndex","findIndex","char","parentElement","parentMatches","matches","firstChild","isSameNode","length","beforePaint","cb","Promise","resolve","requestAnimationFrame","async","getAnimationFromElement","getAnimations","find","dataset","tiAnimationId","setCursorAnimation","animate","pause","play","execute","queueItem","func","call","fireItem","index","wait","wait2","cursorOptions","instantQueue","tempIndex","futureItem","shouldBeGrouped","delay","shouldPauseCursor","q","effect","getComputedTiming","cancel","oldCurrentTime","currentTime","newAnimation","rebuildCursorAnimation","TypeIt","_wait","callback","silent","_statuses","this","unfreeze","_opts","timeouts","setTimeout","_timeouts","_fireItemWithContext","_cursor","_removeNode","rootElement","nodeParent","removeNode","_element","_elementIsInput","_getPace","calculatePace","_getAllChars","filter","getAllChars","_queueAndReturn","steps","opts","_queue","add","_maybeAppendPause","_getDerivedCursorPosition","_predictedCursorPosition","_cursorPosition","_generateTemporaryOptionQueueItems","newOptions","_options","_addSplitPause","items","_attachCursor","_shouldRenderCursor","cursorSelector","computedStyles","getComputedStyle","customProperties","entries","reduce","accumulator","item","setCursorStyles","_id","options2","duration","_generateQueue","string","type","splitItems","_type","typeable","_delete","getTypeable","_fire","remember","cleanUp","qKey","done","getQueue","queueKey","deletable","newIndex","x","y","i","key","derivedCursorPosition","_move","Symbol","reset","set","_prepLoop","e","step","printedCharacters","min","max","allChars","newCursorPosition","nodeToInsertBefore","repositionCursor","originalTarget","character","textContent","target","tagName","insertIntoElement","_empty","slice","break","actionOpts","delete","numCharacters","bookEndQueueItems","num","instant","typeableQueueItems","rounds","empty","exec","move","movementArg","numberOfSteps","directionalStep","cursorable","milliseconds","charsAsQueueItems","outerHTML","nodeType","Node","TEXT_NODE","itemsToQueue","is","destroy","shouldRemoveCursor","clearTimeout","freeze","rebuild","wipe","property","go","IntersectionObserver","observer2","entry","isIntersecting","unobserve","threshold","observe","fireWhenVisible","bind","flush","then","getOptions","updateOptions","getElement","defaultFrames","defaultOptions","processCursorOptions","toString","substring","initialItems","_q","innerText","buildQueueItem","Boolean","rawValues","values","Map","keys","shouldDestroy","get","getItems","Queue","typeitId","className","style","visibility","_setUpCursor","existingMarkup","replace","trim","split","concat","_maybePrependHardcodedStrings","documentElement","targetEl","addEventListener","initMouseInputDetector","typeItAboutMe"],"sourceRoot":""}